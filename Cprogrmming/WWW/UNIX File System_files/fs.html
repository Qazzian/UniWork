<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0101)http://www.aber.ac.uk/compsci/Dept/Teaching/CourseNotes/current/CS23710/UNIX/notes/filesystem/fs.html -->
<HTML><HEAD><TITLE>UNIX File System: Body</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><!--#config timefmt="%e %b %Y" -->
<META content="MSHTML 5.50.4134.600" name=GENERATOR></HEAD>
<BODY bgColor=#e0f0a0><A name=introduction></A>
<H1 align=center>UNIX File System</H1>Chris Loftus, 26 January 1998 <BR>Updated 
by Edel Sherratt, 9 March 1999 and 15 March 2000 <BR>Updated by Helen Fuell, 23 
March 2001 
<H3>Introduction</H3>In UNIX a file is an abstract entity that contains 
information of some type with no imposed structure. In UNIX nearly every 
software concept is a file. 
<UL>
  <LI>Terminals - keyboards, communications lines, modem. 
  <LI>Disks. 
  <LI>Tape drives. 
  <LI>Speakers. 
  <LI>Remote filesystems. 
  <LI>CD-ROM. </LI></UL>
<P>Files can be classified as regular files and special files. 
<H3>Regular files</H3>These include latex files, C source code, binaries, 
directories. <PRE>artemis:cmk&gt; bin/ls -l /usr/5bin
total 988
-rwxr-xr-x  1 root         1552 Oct 11  1990 ar
-rwxr-xr-x  1 root        16384 Oct 11  1990 cat
-rwxr-xr-x  1 root         1661 Oct 11  1990 cflow
-rwxr-xr-x  1 root        16384 Oct 11  1990 chmod
. . . . . . . . . . . . . . . . .
 
artemis:cmk&gt; file /usr/5bin/*
ar:             executable shell script
cat:            sparc demand paged dynamically linked executable
cflow:          executable shell script
chmod:          sparc demand paged dynamically linked executable
. . . . . . . . . . . . . . . . .
</PRE>
<P>The nature of a file (whether shell script, dynamically linked executable 
etc) is determined by commands such as <EM>file</EM> by examining the file's 
contents. System wide or application specific header files detail how such files 
should be organised (see section 4 of the man pages). 
<P>Ordinary files consist of a series of bytes. The file itself has no imposed 
structure and is stored as a stream of bytes. The programs reading or writing 
them will impose any required structure (e.g. integer, float etc). What are the 
implications of this feature for implementing a database? 
<H3>Special files.</H3>These are devices such as tape drives, disks, speakers 
which by convention live in /dev or its subdirectories. A few are shown below: <PRE>marilyn &gt; file /dev/*
/dev/arp:       character special (11/44)
/dev/audio:     character special (108/0)
/dev/audioctl:  character special (108/128)
/dev/bd.off:    character special (29/1)
/dev/be:        character special (11/106)
/dev/conslog:   character special (21/0)
/dev/console:   character special (0/0)
/dev/cua:       directory
/dev/dsk:       directory

marilyn &gt; file /dev/dsk/*
/dev/dsk/c0t3d0s0:      block special (32/24)
/dev/dsk/c0t3d0s1:      block special (32/25)
/dev/dsk/c0t3d0s2:      block special (32/26)
/dev/dsk/c0t3d0s3:      block special (32/27)
</PRE>
<HR>
<A name=directory></A>
<H3>The directory</H3>Directories are regular files but can only be updated 
using special system calls (e.g. <EM>mknod</EM> and <EM>unlink</EM>). Every 
directory has a least two entries ("." and ".."). Each entry in a directory 
exists independently of that directory. The directory entry (called confusingly 
a link) points to an inode structure which, in turn, has a pointer to a file on 
the disk. The inode structure itself will also be on a disk, but in a special 
location (although the list containing it will be partly cached in memory). An 
inode structure defines a file within a disk. Each inode contains information 
about a file such as its owner, group, permissions and physical disk addresses. 
<P><IMG alt="Directory internals" src="fs_files/internal_dir.art" align=middle 
border=1> <A name=inode></A>
<H3>The inode</H3>The inode structure contains information on: 
<OL>
  <LI>User ID. 
  <LI>Group ID. 
  <LI>Protection bits. 
  <LI>Physical disk address. 
  <LI>File size. 
  <LI>Time of creation. 
  <LI>Time last used. 
  <LI>Time of last modification to file (last update). 
  <LI>Time of last modification to inode structure. 
  <LI>Number of links to the file. 
  <LI>Whether the file is: 
  <OL>
    <LI>Directory. 
    <LI>Ordinary file. 
    <LI>Character special file. 
    <LI>Block special file. 
    <LI>Pipe. </LI></OL></LI></OL>
<P>The simplified structure defining the inode is given below. See 
(/usr/include/sys/fs/ufs_inode.h). <PRE>struct inode {
        struct  inode *i_chain[2];      /* must be first */
        struct  vnode i_vnode;  /* vnode associated with this inode */
        struct  vnode *i_devvp; /* vnode for block I/O */
        u_short i_flag;
        dev_t   i_dev;          /* device where inode resides */
        ino_t   i_number;       /* i number, 1-to-1 with device address */
        off_t   i_diroff;       /* offset in dir, where we found last entry */
        ...
        struct  icommon {
           o_mode_t ic_smode;      /*  0: mode and type of file */
           short   ic_nlink;       /*  2: number of links to file */
           o_uid_t ic_suid;        /*  4: owner's user id */
           o_gid_t ic_sgid;        /*  6: owner's group id */
           quad    ic_size;        /*  8: number of bytes in file */
           ...
           time_t  ic_atime;       /* 16: time last accessed */
           long    ic_atspare;
           time_t  ic_mtime;       /* 24: time last modified */
           long    ic_mtspare;
           time_t  ic_ctime;       /* 32: last time inode changed */
           long    ic_ctspare;
           daddr_t ic_db[NDADDR];  /* 40: disk block addresses */
           daddr_t ic_ib[NIADDR];  /* 88: indirect blocks */
           long    ic_flags;       /* 100: status, currently unused */
           long    ic_blocks;      /* 104: blocks actually held */
           long    ic_gen;         /* 108: generation number */
           long    ic_shadow;      /* 112: shadow inode */
           uid_t   ic_uid;         /* 116: long EFT version of uid */
           gid_t   ic_gid;         /* 120: long EFT version of gid */
           ulong   ic_oeftflag;    /* 124: reserved */
       } i_ic;
};
</PRE>For details of storage of files on the physical disk see page 578 <A 
href="http://www.aber.ac.uk/compsci/Dept/Teaching/CourseNotes/current/CS23710/UNIX/notes/references.html#DET90">[DET90]</A>, 
and Chapter 4 <A 
href="http://www.aber.ac.uk/compsci/Dept/Teaching/CourseNotes/current/CS23710/UNIX/notes/references.html#BACH86">[BACH86]</A>. 

<HR>
<A name=permissions></A>
<H3>File access permissions</H3>The permissions associated with a file exist to 
determine if an operation such as opening a file, reading from a file, etc, can 
be performed. The information about file permission is stored in the file's 
inode structure (in the ic_imode field). It is stored as an unsigned short int 
number which can be changed by C's bitwise inclusive OR operator "|". For 
example, this would be done to set a permission mode when creating a new file. 
<P>An example of using the "|" operator on two 16 bit binary numbers is: <PRE>0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1         Decimal 1 or octal 1 in binary
0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0         Decimal 256 or octal 400 in binary
|
0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1         Result: Decimal 257 or octal 401 in binary
</PRE>Since the byte size of a Sun is 8 bits, a short, which is 2 bytes on a 
Sun, is 16 bits. Each of these 16 bits switches on or off a particular file mode 
(some of which are concerned with permissions). 
<P>UNIX protects files with reference to three classes of user: 
<UL>
  <LI>Owner of the file. 
  <LI>Group owner of the file. 
  <LI>Other potential users of the file. </LI></UL>
<P>Every file will have a separate set of permissions for each of these three 
user groups. These determine whether these users can read, write or execute the 
file. These modes (permissions and others) are: 
<TABLE>
  <TBODY>
  <TR>
    <TD><B>Mode (octal)</B></TD>
    <TD><B>Description</B></TD></TR>
  <TR>
    <TD>400</TD>
    <TD>Read by owner.</TD></TR>
  <TR>
    <TD>200</TD>
    <TD>Write by owner.</TD></TR>
  <TR>
    <TD>100</TD>
    <TD>Execute (search in directory) by owner.</TD></TR>
  <TR>
    <TD>040</TD>
    <TD>Read by group.</TD></TR>
  <TR>
    <TD>020</TD>
    <TD>Write by group. </TD></TR>
  <TR>
    <TD>010</TD>
    <TD>Execute (search in directory) by group.</TD></TR>
  <TR>
    <TD>004</TD>
    <TD>Read by others.</TD></TR>
  <TR>
    <TD>002</TD>
    <TD>Write by others.</TD></TR>
  <TR>
    <TD>001</TD>
    <TD>Execute (search in directory) by others.</TD></TR>
  <TR>
    <TD>4000</TD>
    <TD>Set user ID on execution.</TD></TR>
  <TR>
    <TD>2000</TD>
    <TD>Set group ID on execution.</TD></TR>
  <TR>
    <TD>1000</TD>
    <TD>Set sticky bit.</TD></TR></TBODY></TABLE>Octal numbers are usually used when 
setting file modes. For example, the shell command <EM>chmod</EM> is often given 
file permissions in this form. Hence <EM>chmod 777 file</EM> is equivalent to 
<EM>chmod a=rwx file</EM>. A combination of 0641 (in C placing a 0 as the first 
digit indicates that a literal number should be treated as an octal) when 
defining a file mode would mean: 
<UL>
  <LI>no set-uid, gid-uid or sticky bit permissions. 
  <LI>read and write permissions for owner. 
  <LI>read permissions for group. 
  <LI>execute permission for others. (search if a directory). </LI></UL>
<P><EM>ls -l</EM> on a file that had this mode would give: <PRE>-rw-r----x   1 cwl      staff       1655 Apr 16  1996 vmstat.log
</PRE>Note how the last 9 binary digits of 000000000110100001 corresponds to the 
above. The upper half of this number is used for other mode information (e.g. 
digits 10 to 12 for set id and sticky bits). 
<P>As directories cannot be executed, the execute bit has a special meaning, 
i.e. that the directory can be searched by the owner, group or others depending 
on whether it is set or unset for each of these users. 
<HR>
<A name=umask></A>
<H4>Umask</H4>It is often useful to set a mask which will, by default, mask out 
specific permissions, e.g. make sure that all files created have no write 
permission for others or the group. <EM>umask</EM> can be used to set such a 
mask and can be called from either the shell or from within a program. 
<P>A child process will inherit the mask of its parent. That way, if you set the 
mask in your .cshrc file you know that any program you start will inherit this 
mask (it may of course override it). Whenever you create a file using 
<EM>open</EM> or <EM>fopen</EM> (or any file/directory creation call) the mask 
is implicitly applied to the user's supplied file creation mode. UNIX will use 
the bitwise AND ("&amp;") operator in the following expression: <PRE>(~mask)&amp;supplied_mode
</PRE>For example if the mask is set to 033 (----wx-wx) this means prevent the 
creation of files with write and execute permissions for the group and others. 
If the user program then tries to create a file with the mode 0655 (rw-r-xr-x) 
the negation of the mask (i.e. rwxr--r--) is ANDed with this mode causing the 
unwanted permissions to be switched off (set to zero) leading to a final file 
mode 0644 (rw-r--r--). 
<P>If you want to make sure that the mode provided during file creation is not 
masked, then you should call <EM>umask</EM> with the value 0. <EM>umask</EM> 
will also return the value of the previous mask. This allows you to temporarily 
change a mask and then reset it later. 
<P>The following code provides a more complex example: <PRE>#include &lt;fcntl.h&gt;    /* Required for flags O_RDWR etc */
#include &lt;stdio.h&gt;    /* Defines IO library functions */
#include &lt;unistd.h&gt;   /* Declares unlink */
#include &lt;sys/stat.h&gt; /* Declares umask */

int main(int argc, char **argv)
{
  int fd;
  FILE *filedes;
  int origmask, mask = 0033, zero_mask = 0;
 
  /* Remove any previous files created */

  unlink(argv[1]);    unlink(argv[2]);
  unlink(argv[3]);    unlink(argv[4]);
 
  /* Set the mask to prevent writing and execution permissions for
     group users or other users being set when creating new files.
     Keep hold of the original mask. */

  origmask = umask(mask);
 
  /* Create a new file using open system call and specify the mode as rw-r-xr-x.
     The mask will be applied implicitly and filter out
     the two execute permissions for group and other users.
     The file will actually be created with: rw-r--r-- */

  if (( fd = open(argv[1], O_RDWR | O_CREAT, 0655)) == -1) {
    fprintf(stderr, "open failed\n");
    exit(1);
  }
  close(fd);

  /* Create a new file using the fopen library function with
     the intention of appending. Although
     we don't explicitly say what the mode is for each of the three
     groups of users, the system will set the mode to read and write
     for each kind of user. However because the mask is set to screen
     out rw for group and others the file will actually be created with
     permissions: rw-r--r-- */

  if ((filedes = fopen(argv[2], "a+")) == NULL)    {
    fprintf(stderr, "fopen failed\n");
    exit(1);
  }
  fclose(filedes);
 
  /* We now set the mask to zero so that file modes are unaffected during
     file creation */

  origmask = umask(zero_mask);
 
  /* This time the file will be created with rw-r-xr-x */

  if (( fd = open(argv[3], O_RDWR | O_CREAT, 0655)) == -1) {
    fprintf(stderr, "open failed\n");
    exit(1);
  }
  (void)close(fd);

  /* This time the file will be created with rw-rw-rw- */

  if (( filedes = fopen(argv[4], "a+")) == NULL)    {
    fprintf(stderr, "fopen failed\n");
    exit(1);
  }
 
  fclose(filedes);

  return 0;
}
</PRE>This gives: <PRE>marilyn.dcs.aber.ac.uk 53 &gt; main one two three four
marilyn.dcs.aber.ac.uk 54 &gt; ls -l
total 16
-rw-rw-rw-   1 cwl      staff          0 Feb  5 09:48 four
-rw-r--r--   1 cwl      staff          0 Feb  5 09:48 one
-rw-r-xr-x   1 cwl      staff          0 Feb  5 09:48 three
-rw-r--r--   1 cwl      staff          0 Feb  5 09:48 two
</PRE>
<HR>
<A name=setid></A>
<H4>set-uid and Set-gid</H4>The patent for this concept is held by Dennis 
Ritchie and involves setting the permissions of a file so that when executed, 
the program process will execute with the permissions that the owner of the file 
has, not with the permissions of the user executing it (which is the default). 
<P>An example of the use of setting the user id is the file containing the 
program which changes a password entry (nispasswd on Computer Science). For 
obvious security reasons the central database containing password information (a 
Network Information Service password map file) must only be updatable by root on 
the machine containing that database. It is inconvenient for users to have to 
request that the administrator change their passwords. Instead, because the root 
user has set the set-uid bit for the nispasswd program file, it will take on the 
identity of root (the file's owner) during execution. In this way the humble 
user is able to change his/her password information. <PRE>-r-sr-sr-x   3 root     sys        15688 Oct 25  1995 /usr/bin/nispasswd
</PRE>Note that the set-uid and set-gid bits have been set for nispasswd since 
the process should take on the identity of both the root user and his group 
(sys). <EM>ls -l</EM> displays set-id information as an "s" in place of the 
normal "x". There are potential dangers associated with setting the set-id bits. 
A user who does this to one of his/her programs creates a potential security 
loop-hole through which other users can pass. For example, the program might 
update his/her local files. 
<HR>
<A name=sticky></A>
<H4>The Sticky bit</H4>As described in the <A 
href="http://www.aber.ac.uk/compsci/Dept/Teaching/CourseNotes/current/CS23710/UNIX/notes/overview/ov.html#process">Overview 
notes</A> a process has a number of sections. The text section of a process will 
be the same for all processes running the same program (e.g. multiple executions 
of <EM>ls</EM>) at the same time. Therefore the system need only keep one copy 
in memory for any number of concurrent invocations of that program. 
<P>Normally, when the program text is no longer required by any processes it is 
deleted from memory. For frequently executed programs this is inefficient, since 
creating the program image in memory is expensive requiring lots of disk 
activity (e.g. dynamic linking etc). It used to be the case that if the 
sticky-bit (also called save-text-image bit) on the executable file was set then 
once an image is used, it will not be deleted from virtual memory, but swapped 
out into secondary memory so that when it is next used it is just swapped back 
in, instead of being searched for and loaded from the filesystem. However, this 
use of the sticky bit no longer applies. 
<P>The sticky bit can also be set for ordinary text files and directories. Why 
directories? There are some directories that have write access set for others, 
and not just the owner. The /tmp directory is an example. Normally, where this 
is the case users are able to delete files owned by other users from this 
directory (since everyone has write permission for the directory). This is often 
undesirable, such as the case of /tmp. Setting the sticky bit on the directory 
will prevent users from deleting files they do not own from the directory. Only 
the owner of the file, the owner of the directory and superuser are allowed to 
delete the file. Setting the sticky bit on an ordinary file will result in it 
being cached in the swap partition, allowing fast retieval at run time. This may 
be useful where a file is used by lots of processes. 
<P>Set-uid, set-gid and the sticky bit are set either using <EM>chmod(2)</EM> or 
from within a program as part of the mode argument. 
<P>A simple shell script can be used to find all files that are set-uid, set-gid 
and have the sticky bit set in a filesystem (this would have taken a lot more 
lines of C to write). <PRE>#!/bin/sh
# A script to find various file types
 
for file in `find $1 -type f -print`
  do
     if [ -u $file ] ; then
        echo $file " is a set-id file"
     fi
     if [ -g $file ] ; then
        echo $file " is a set-gid file"
     fi
     if [ -k $file ] ; then
        echo $file " has the sticky bit set"
     fi
   done
</PRE>
<HR>
<A name=IO></A>
<H3>Unbuffered Input/Output</H3>The collection of primitives (system calls) 
which can be put under the heading of unbuffered I/O are: 
<UL>
  <LI>open - opens or creates a file for reading and/or writing. 
  <LI>read - reads bytes from a file. 
  <LI>write - writes bytes to a file. 
  <LI>unlink - removes a file. 
  <LI>lseek - moves to a specified byte in a file. 
  <LI>close - closes a previously opened file. </LI></UL>
<P>Since the UNIX file has no imposed structure, being a stream of bytes, the 
above primitives do not need to take any structure into account. The calls give 
direct access to the I/O facilities that the kernel provides. Irrespective of 
the type of file (special or regular) it will ultimately be accessed via these 
system calls (there are a couple of general purpose IO related system calls 
(fcntl and ioctl) but these can be ignore for the moment). They are the building 
blocks for all I/O. 
<P>The interface (e.g. functions and constants) is described in <EM>fcntl.h</EM> 
and this header file should be included in all programs that use unbuffered I/O. 

<P>This form of IO is termed unbuffered because, unlike the standard IO 
libraries (fopen etc), no buffering is done on behalf of the user program 
(except by the kernel for performance reasons). Instead, the user program is 
required to provide a buffer into which bytes are read. The user program is then 
responsible for interpreting and managing that buffer. 
<P>We now describe each of the above system calls. Note that the return values 
of most (but not all) system calls are as follows: 
<UL>
  <LI>0 or positive number on success. 
  <LI>-1 or NULL on failure. This will set the external variable <EM>errno</EM> 
  to indicate the error (see Intro(2) for error numbers and what they mean). 
  </LI></UL>
<P>
<HR>
<A name=open></A>
<H4>Open</H4><PRE>     int open(const char* path, int flags [, int mode]);
</PRE>This call is used to open or create a file for reading and/or writing. It 
takes a UNIX pathname and returns a file descriptor which should be used by 
other IO system calls accessing the file. The file descriptor is just an index 
into the process' file descriptor table. This table then enables access to the 
inode structure for the file. Each process is allowed only a finite number of 
file descriptors. Also, by default, each process inherits the file descriptors 
of its parent (e.g. standard input, standard output and standard error). 
<P>The flags argument comprises a logical OR (the "|" C operator) of one or more 
flags like those in the list below. This argument indicates what is done with 
the file when it is opened. 
<P>
<UL>
  <LI><B>O_RDONLY</B> Open for reading only. 
  <LI><B>O_WRONLY</B> Open for writing only. 
  <LI><B>O_RDWR</B> Open for reading and writing. 
  <LI><B>O_CREAT</B> Create the file if it doesn't already exist. 
  <LI><B>O_APPEND</B> File pointer is set to the end of the file before each 
  write. 
  <LI><B>O_TRUNC</B> Truncates the file to length 0 if it exists. 
  <LI><B>O_EXCL</B> Open fails if the file exists. </LI></UL>
<P>The mode (as shown <A 
href="http://www.aber.ac.uk/compsci/Dept/Teaching/CourseNotes/current/CS23710/UNIX/notes/filesystem/fs.html#permissions">earlier</A>) 
argument specifies the permissions of a new file to be created (specified by the 
O_CREAT flag). This parameter is ignored if the file already exists. 
<P><EM>open</EM> can be used to create lock files which act as binary semaphores 
(netscape creates such a file in your .netscape directory). These lock files are 
then used to control access to a resource (such as writing to another file where 
only one process should write to the file at a time). A process wishing to write 
to such a file would attempt to create the lock file with the O_CREAT and O_EXCL 
flags set. If the file already exists, it means another process has already 
acquired the resource. If not, then the lock file is created and the process 
acquires the resource (in this case updates the file). 
<P>
<HR>
<A name=read></A>
<H4>Read</H4><PRE>ssize_t read(int fd, void *buf, size_t nbyte);
</PRE><EM>read()</EM> attempts to read <EM>nbyte</EM> bytes of data from the 
object referenced by the descriptor <EM>fd</EM> into the buffer pointed to by 
<EM>buf</EM>. It returns the number of bytes read, or -1 on error. 
<P>If there are no bytes to read then end of file (EOF) is returned (value 0). A 
call to <EM>read</EM> will block until the IO request is serviced (the data is 
read from the disk). This can be a problem sometimes and so it is possible to 
either stop blocking using the <EM>fcntl</EM> system call or to set an alarm 
signal to fire after a user-defined time (see <A 
href="http://www.aber.ac.uk/compsci/Dept/Teaching/CourseNotes/current/CS23710/UNIX/notes/ipc/interprocess.html#signals">signal 
notes</A>). 
<P>It is often a good idea (for performance reasons) to set the buffer size to 
<EM>BUFSIZ</EM> (a constant defined in stdio.h) since this is the size of chunks 
of data read to and from the disk and the kernel. 
<P>The <EM>void*</EM> pointer type means that you can read bytes into any kind 
of pointer data structure (e.g. pointer to structs, strings, arrays, ints etc). 
Remember that you are simply reading a stream of bytes and that it is the 
program which assigns structure and type to that information. 
<HR>
<A name=write></A>
<H4>Write</H4><PRE>ssize_t write(int fd, void* buf, size_t nbyte);
</PRE><EM>write()</EM> attempts to write <EM>nbyte</EM> bytes of data to the 
object referenced by the descriptor <EM>fd</EM> from the buffer pointed to by 
<EM>buf</EM>. It returns the number of bytes written, or -1 on error. 
<P><EM>write</EM> can block due to full kernel buffers (waiting for buffers to 
be written to disk). Again, an alarm signal can be set to cause a timeout to 
avoid excessive blocking. Again, <EM>void*</EM> means that you can write out any 
kind of data structure via a supplied pointer to that data structure. 
<HR>
<A name=lseek></A>
<H4>Lseek</H4><PRE>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
 
off_t lseek(int fd, off_t offset, int whence);
</PRE><EM>lseek()</EM> sets the file pointer to a specified location in the 
file. The file pointer is a marker to the location of the last read or write. 
<P>There are three parameters. <EM>fd</EM> is an open file descriptor. 
<EM>offset</EM> is the number of bytes to move the file pointer (forwards if 
positive or backwards if negative) from the current position or from the start 
or end of the file. <EM>whence</EM> is used to indicate the start position: 
<UL>
  <LI><B>SEEK_SET</B> - Start of the file plus offset. 
  <LI><B>SEEK_CUR</B> - Current location plus offset. 
  <LI><B>SEEK_END</B> - Size of the file plus offset. </LI></UL>
<P><EM>lseek</EM> returns the number of bytes from the start of the file. Some 
devices (in particular character special files) such as audio devices are 
incapable of seeking. 
<HR>
<A name=unlink></A>
<H4>Unlink</H4><PRE>int unlink(const char *path);
int remove(const char *path);
</PRE><EM>unlink()</EM> removes the reference to a file from a directory entry 
and decrements the link count in the inode structure of the file referenced. If 
this becomes zero then the inode structure will be placed on a list of free 
available inodes, and the associated file data blocks are placed on a list of 
free and available data blocks. 
<P>If a relative pathname is given then <EM>unlink</EM> searches from the 
current working directory. Only the last element of the pathname is removed. 
<P><EM>remove()</EM> is identical with <EM>unlink</EM> for files but will also 
remove empty directories. 
<HR>
<A name=close></A>
<H4>Close</H4><PRE>int close(int fd);
</PRE><EM>close</EM> deletes a descriptor from the per-process object reference 
table thereby closing the file. When a process exits, all open file descriptors 
are closed. 
<HR>
<A name=example></A>
<H4>Example program</H4>The following program demonstrates the use of the IO 
system calls. It 
<UL>
  <LI>takes a filename from the command line, 
  <LI>opens or creates the file, 
  <LI>appends some text to the file, 
  <LI>reads a chunk of data from the start of the file, 
  <LI>executes the <EM>ls</EM> command 
  <LI>removes the file from its directory entry. </LI></UL>
<P><PRE>#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;    /* only for BUFSIZ definition and sprintf */
#include &lt;malloc.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdlib.h&gt;   /* Defines system function */


#define PROG_BUFSIZE BUFSIZ     /* buffer size, same as block size 1024 */
#define COMMAND "/bin/ls -l"    /* command to be executed */
 
char *thing_to_write = "a thing to write\n";
extern char *sys_errlist[];       /* external list of all error messages */
 
int main(int argc, char **argv)
{
   int filedes;      /* A file descriptor */
   char *inbuf;      /* buffer to read into */
   char command[40]; /* command to execute  ls -l */
 
   (void) sprintf(command, "%s %s",COMMAND, argv[1]);
 
   /* open file for reading and writing, append output to end of file */

   if ((filedes = open(argv[1], O_RDWR | O_APPEND | O_CREAT, 0644)) == -1) {
      (void) fprintf(stderr, "error opening file %s : %s\n",
                              argv[1], sys_errlist[errno]);
      exit(1);
   }
 
   /* Write out some text. Note that we find the size of char
      when calculating the number of bytes is to be written. This isn't
      strictly necessary since char = 1 byte, but it makes our code more
      portable (just in case another machine perversely used 2 bytes to
      implement a char!) */

   if ((write(filedes, thing_to_write, 
              strlen(thing_to_write) * sizeof(char))) == -1)   {
      (void)fprintf(stderr, "error writing to file %s : %s\n",
                             argv[1], sys_errlist[errno]);
      exit(1);
   }
 
  lseek(filedes, 0, SEEK_SET); /* set file pointer to start of file */
 
  /* Create a buffer of an optimal size */

  inbuf = (char *) malloc(PROG_BUFSIZE * sizeof(char));
  if (inbuf == NULL) {  /* test if malloc failed */
     (void)fprintf(stderr, "malloc failed allocating inbuf :
                            %s\n", sys_errlist[errno]);
     exit(1);
  }

  /* Now try and fill inbuf with data from the file */

  if((read(filedes, inbuf, PROG_BUFSIZE)) == -1) { /*read file descriptor*/
     (void)fprintf(stderr, "error reading from file %s : %s\n",
                            argv[1], sys_errlist[errno]);
     exit(1);
  }
 
  close(filedes);
 
  /* system is a quick way of starting other processes from this process */

  system(command);
  unlink(argv[1]);

  /* This time, ls -l will not list the file */
  system(command);
 
  /* Now write directly to standard output. No test needed. */
  write(1,inbuf, strlen(inbuf) * sizeof(char)); 

  free(inbuf);   /* deallocated memory allocated by malloc */
 
  /* The following is very dangerous since inbuf is now deallocated. It
     may produce the same output but it may also write garbage
     or cause a segmentation violation (outside process' address space)*/

  write(1, inbuf, strlen(inbuf));

  return 0;
}
</PRE>
<HR>
<A name=getc></A>
<H4>The implementation of getc</H4><EM>getc</EM> is a macro defined in the 
system header file stdio.h. It demonstrates how buffering is managed by the 
standard IO library. Its definition is: <PRE>#define getc(p)         (--(p)-&gt;_cnt&lt;0 ? (__filbuf(p) : (int)*(p)-&gt;_ptr++)
</PRE>This is interpreted as: 
<UL>
  <LI>p - the FILE* stream to be read from 
  <LI>_cnt - characters remaining in the buffer 
  <LI>_ptr - next character in the buffer </LI></UL>
<P><EM>getc</EM> is a macro which on each call returns the first character in 
the buffer <EM>_ptr</EM>, decrements the count <EM>_cnt</EM>, and advances the 
pointer <EM>_ptr</EM> to indicate the next character to be returned in the event 
of that stream being read. When the count <EM>_cnt</EM> gets to 0 then the 
<EM>_filbuf</EM> function is called to read a block of characters (1024) from 
stream <EM>p</EM> into a buffer <EM>_ptr</EM>. <EM>_filbuf</EM> returns the 
first character in the buffer. 
<P>The macro uses one of those strange C conditional expressions. Basically, the 
first part of the expression (<EM>--(p)-&gt;_cnt&lt;0</EM> says that if after 
decrementing _cnt by 1 it is less than zero then return true else return false. 
If it returned false, then <EM>((int)*(p)-&gt;_ptr++)</EM> is executed, i.e. 
return the character being pointed to by <EM>_ptr</EM> and increment the pointer 
by one. If it returned true, then <EM>_filebuf(p)</EM> is called and the buffer 
gets refilled. 
<P>This avoids reading a single character every time getc is called, and is 
called buffering. UNIX is most efficient when it reads from a file in multiples 
of the system block size (BUFSIZ). <PRE>#include &lt;stdio.h&gt;
 
int main()
{
  char c;
 
  for(;;) {
    c = getc(stdin);
    (void) printf("%c\n",c);
  }

  return 0;
}
</PRE>
<HR>
<A name=stat></A>
<H3>Stat and Statvfs</H3><PRE>int stat(char* path, struct stat* buf);
</PRE><EM>stat</EM>, <EM>lstat</EM> and <EM>fstat</EM> obtain information about 
a file's status, the information is derived from the file's inode structure. 
<UL>
  <LI><B>stat</B> - file is named by a path e.g. /usr/bin/cc. It obtains 
  information about the file pointed to by path. 
  <LI><B>lstat</B> - lstat behaves the same as stat except where the named file 
  is a symbolic link. In that case lstat returns information about the symbolic 
  link file, while stat returns information about the file the link references. 
  <LI><B>fstat</B> - here an open file is referenced by a open file descriptor 
  (returned from fopen). Behaves the same as stat. </LI></UL>
<P><EM>stat</EM> (stat is used as a generic term for stat, lstat and fstat; only 
the description of how the file is named differs). It takes as its second 
argument a pointer to a structure into which information is placed. The form of 
the stat structure is described in the header file /usr/include/sys/stat.h and 
is shown below. <PRE>dev_t          st_dev;     /* device file resides on */
ino_t          st_ino;     /* the file serial number */
mode_t         st_mode;    /* file mode */
nlink_t        st_nlink;   /* number of hard links to the file */
uid_t          st_uid;     /* user ID of owner */
gid_t          st_gid;     /* group ID of owner */
dev_t          st_rdev;    /* the device identifier (special files only) used 
                              to find device driver*/
off_t          st_size;    /* total size of file, in bytes */
timestruc_t    st_atime;   /* file last access time */
timestruc_t    st_mtime;   /* file last modify time */
timestruc_t    st_ctime;   /* file last status change time */
long           st_blksize; /* preferred blocksize for file system I/O*/
long           st_blocks;  /* actual number of blocks allocated */
</PRE>A number of macros are available which can be used to test the 
<EM>st_mode</EM> field using bitwise arithmetic to determine various attributes 
of the file. These are also defined in stat.h and stat(2) and most are described 
below: 
<P>Macro tests for file types: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>S_ISDIR(m) </TD>
    <TD>Test for directory file. </TD></TR>
  <TR>
    <TD>S_ISCHR(m) </TD>
    <TD>Test for character special file. </TD></TR>
  <TR>
    <TD>S_ISBLK(m) </TD>
    <TD>Test for block special file. </TD></TR>
  <TR>
    <TD>S_ISREG(m) </TD>
    <TD>Test for regular file. </TD></TR>
  <TR>
    <TD>S_ISLNK(m) </TD>
    <TD>Test for a symbolic link. </TD></TR>
  <TR>
    <TD>S_ISSOCK(m) </TD>
    <TD>Test for a socket. </TD></TR>
  <TR>
    <TD>S_ISFIFO(m) </TD>
    <TD>Test for pipe or FIFO special file. </TD></TR></TBODY></TABLE>
<P>Predefined constants for other mode information (permissions, set-id). For 
each you can use C's bitwise AND ("&amp;") operator to see if the st_mode has 
the given mode set: <PRE>if (mode &amp; S_IRUSR) { /* Will be &gt; 0 if set */
   printf("User has read permission set\n");
}
</PRE>
<P>Owner permissions: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>S_IRWXU </TD>
    <TD>Read, write, or execute permissions mask.</TD></TR>
  <TR>
    <TD>S_IRUSR </TD>
    <TD>Read permission bit.</TD></TR>
  <TR>
    <TD>S_IWUSR </TD>
    <TD>Write permission bit. </TD></TR>
  <TR>
    <TD>S_IXUSR </TD>
    <TD>Execute permission bit. </TD></TR></TBODY></TABLE>
<P>Group permissions: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>S_IRWXG </TD>
    <TD>Read, write, or execute permissions mask.</TD></TR>
  <TR>
    <TD>S_IRGRP </TD>
    <TD>Read permission bit.</TD></TR>
  <TR>
    <TD>S_IWGRP </TD>
    <TD>Write permission bit. </TD></TR>
  <TR>
    <TD>S_IXGRP </TD>
    <TD>Execute permission bit. </TD></TR></TBODY></TABLE>
<P>Permissions for others: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>S_IRWXO </TD>
    <TD>Read, write, or execute permissions mask.</TD></TR>
  <TR>
    <TD>S_IROTH </TD>
    <TD>Read permission bit.</TD></TR>
  <TR>
    <TD>S_IWOTH </TD>
    <TD>Write permission bit. </TD></TR>
  <TR>
    <TD>S_IXOTH </TD>
    <TD>Execute permission bit. </TD></TR></TBODY></TABLE>
<P>Set-id modes: 
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD>S_ISUID </TD>
    <TD>Set user ID on execution. </TD></TR>
  <TR>
    <TD>S_ISGID </TD>
    <TD>Set group ID on execution. </TD></TR></TBODY></TABLE>
<P>If the file is a directory, then the execute permission bit indicates whether 
the directory can be searched. 
<P>The following program determines if a file's owner has write permission. <PRE>#include &lt;sys/stat.h&gt;
#include &lt;stdio.h&gt;
 
int main(int argc, char **argv)
{
  struct stat buf;
 
  if (stat(argv[1], &amp;buf) == -1)    {
     perror("stat failed");  /* perror will display a system generated
                                message followed by the string argument */
     exit(1);
  }
 
  if (buf.st_mode &amp; S_IWUSR) {
     printf("%s has write permission\n", argv[1]);
     printf("%lo\n",buf.st_mode &amp; S_IWUSR);
  }
  return 0;
}
</PRE><EM>statvfs</EM> returns information about a mounted file system. The 
following is an example of its use. <PRE>#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/statvfs.h&gt;   /* for statvfs */
#include &lt;sys/stat.h&gt;
#include &lt;errno.h&gt;
 
extern int errno;   /* declaration of system error messages */
extern char *sys_errlist[];
void file_sys_stats(char *);
 
int main(int argc, char **argv)
{
  struct stat buf;
 
  if (stat(argv[1], &amp;buf) == -1)      {
     fprintf(stderr, "stat failed - %s\n", sys_errlist[errno]);
     exit(1);
  }
 
  if (S_ISDIR(buf.st_mode))   /* test if the file is a directory */
     file_sys_stats(argv[1]);
  else
     printf("File %s has a uid = %d and a  gid = %d\n",
                   argv[1], (int)buf.st_uid, (int)buf.st_gid);

  return 0;
}
 
void file_sys_stats(char *file_system)
{
  struct statvfs buf;
    
  if (statvfs(file_system, &amp;buf) == -1)   {
     fprintf(stderr, "statfs failed - %s\n",sys_errlist[errno]);
     exit(1);
  }
 
  printf("\n\t FILE SYSTEM STATISTICS FOR %s\n", file_system);
  printf("\tfundamental system block size     - %ld\n",buf.f_bsize);
  printf("\ttotal blocks in the system        - %ld\n",buf.f_blocks);
  printf("\tfree blocks                       - %ld\n",buf.f_bfree);
  printf("\tfree blocks available to non-root - %ld\n",buf.f_bavail);
  printf("\ttotal file nodes in the system    - %ld\n",buf.f_files);
  printf("\tfree file nodes in fs             - %ld\n",buf.f_ffree);
  printf("\tfile system id\t\t\t  - %ld\n",buf.f_fsid);
}
</PRE>You may want to use statvfs to see if there is enough space on the file 
system when writing data to files. 
<HR>
<A name=special></A>
<H3>Special files</H3>Special files such as printers, disks, tapes etc are, from 
the point of view of the programmer, read from and written to in the same way as 
regular files. All operations on all files use the primitives of <EM>open, read, 
write, lseek, unlink, close</EM>. So a read from a disk is conceptually the same 
as a read from a terminal. The kernel, via the device driver, presents the 
hardware with information in an appropriate form. Therefore the interface for 
communication with devices is the same as communications with regular files. 
This is one of the features that is most attractive about UNIX. 
<P>Ultimately, all file system regular files map to special files. When your 
program opens a regular file, the kernel will find its block special file and 
will read and write directly via this special file. In effect the kernel is 
providing an abstraction: you deal with the concepts of the file system and the 
kernel translates your requests to disk operations. 
<P>The screen is a special file which can be written to (not all operations need 
to be supported by the device driver). Each Xterminal will have a 
pseudo-terminal associated with it which can be read from and written to. 
<P>Input/Output is performed as a stream of bytes. Each special file is 
identified by a major device number (specifies which device driver to use) and a 
minor device number (specifies which device the device driver should use). These 
values are contained in the <EM>st_rdev</EM> field returned by <EM>stat</EM> 
<HR>
<A name=filesystem></A>
<H3>The file system</H3>A file system is a collection of files and directories 
that are organised in a hierachical structure and are visible on a machine. The 
files or directories do not need to be physically on the machine. File systems 
can be mounted from other machines and inserted into the directory hierarchy. 
<P>The following diagram represents a file system. 
<P><IMG alt="A simplified and incomplete Unix filesystem." 
src="fs_files/directory_hier.art" align=middle border=1> 
<P>Going from left to right: 
<UL>
  <LI>/dcs and /mntfs/pgrad1 to /mntfs/other2 are mount points. That is they are 
  locations in one file system where parts of other file systems can be mounted 
  such that they appear to me local. More is said about <EM>mount</EM> below. 
  Note that dcs file systems come from the Computer Science LAN whereas the 
  others are mounted from the Computer Unit LAN. 
  <LI>/dev and /devices contains special files. 
  <LI>/etc contains utility programs such as <EM>ls</EM> and <EM>cat</EM>. 
  <LI>/var contains OS workspace, e.g. for printer spool files. 
  <LI>/usr contains system object code libraries, include files, administration 
  utility programs and locally installed software and its associated libraries 
  and binaries. 
  <LI>/kernel contains the kernel program and important system binaries such as 
  the scheduler. 
  <LI>/sbin contains admin utility programs and start-up scripts. 
  <LI>/proc contains file representations of running process images. </LI></UL>
<P>The dotted lines represent symbolic links. 
<HR>
<A name=mount></A>
<H3>Mount points</H3>The <EM>mount</EM> command attaches a named file system to 
the file system hierarchy at the specified pathname directory. The attachment 
point is known as a mount point and looks like a directory. It is possible to 
either mount file systems from local disk partitions or to mount them from 
remote disk partitions. The latter is achieved via several daemon processes (run 
as kernel threads): 
<UL>
  <LI>Networked File System daemon (nfsd). 
  <LI>Block IO daemon (biod). 
  <LI>Mount daemon (mountd). 
  <LI>Automount daemon (amd). </LI></UL>
<P>The kernel knows from kernel data structures whether a file is local or 
remote. If remote it uses the above daemons (and underlying RPC mechanisms) to 
enable access to the file. As far as the user is concerned the file appears to 
be local (apart from a slower response time). The automount daemon enables the 
mount operation to be performed by the kernel only when it needs to be, i.e. 
when a request is made to access a remote file via the mount point. In this way 
coupling between machines is reduced. Also, the automounter provides several 
other advantages such as the ability to decide which remote file system to mount 
from several alternatives (e.g. if one machine is down another can be used 
instead). This topic is discussed in detail in <A 
href="http://www.aber.ac.uk/compsci/Dept/Teaching/CourseNotes/current/CS23710/UNIX/notes/references.html#CB94">[CB94]</A>. 

<P>Mount is a privileged command that only root ( superuser ) can execute, 
however you can print out all the file systems mounted with /usr/etc/mount -p 
<P><EM>umount</EM> unmounts a file system. 
<HR>
<A name=links></A>
<H3>File links</H3>A file can have a "link" to it. This implies that more than 
one directory entry can contain a reference to the same inode. These are called 
hard links. They cannot be created between file systems. This is because inode 
numbers are file system specific. Also, they cannot be created to directories 
(except by using mkdir and mknod). This is to stop circular paths from being 
created in the file system (note that ".." and "." are the exceptions, but are 
created by the kernel as a side-effect of the <EM>mknod</EM> system call). The 
<EM>mknod</EM> system call must be used if a directory needs creating. Hard 
links can be created from the command line using: <PRE>ln filename linkname
</PRE><EM>filename</EM> is the name of the original file or directory. 
<EM>linkname</EM> is the new name. This makes <EM>linkname</EM> point to the 
same inode as <EM>filename</EM>. Links can only be made to existing files. Links 
are created using the <EM>link</EM> system call. <PRE>int link(char* path1, char* path2);
</PRE><EM>path1</EM> is the existing file, <EM>path2</EM> is the new directory 
entry. A symbolic link (BSD UNIX and derivatives only, including solaris) permit 
the creation of a link which can span a file system. These links are implemented 
by storing the name of the file being linked to rather than the inode in the 
directory link. Therefore a reference can exist to a file that does not exist; 
there are no checks made by the kernel and the link count of the inode structure 
of the referenced file is not changed. <PRE>void:cmk&gt;ls -l
total 5
-rw-r--r--  2 cmk          1077 Oct 21 18:59 hard_link.bib
lrwxrwxrwx  1 cmk             8 Oct 21 19:00 softlink.bib -&gt; unix.bib
-rw-r--r--  2 cmk          1077 Oct 21 18:59 unix.bib
</PRE>The number before softlink.bib is a pointer to a memory location 
containing the soft link value (e.g. unix.bib in this case). For hard link 
entries this pointer would be to an inode number instead. 
<HR>
<A name=fcntl></A>
<H3>Fcntl, Dup and Dup2</H3>The <EM>fcntl</EM> system call provides a 
significant degree of control over an already open file. It is intended to 
perform a variety of functions such as: 
<UL>
  <LI>File locking. 
  <LI>Get various file descriptor attributes. 
  <LI>Duplicate a file descriptor. 
  <LI>Help control the interaction of files and processes, e.g. ensuring that 
  fds are closed when a child process is started. 
  <LI>Setting non-blocking I/O so that reads and write always immediately return 
  (and with the value 0 if nothing was read or written). </LI></UL>
<P><PRE>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
 
int fcntl(int fd, int cmd, int arg);
</PRE>The following is an example that: 
<UL>
  <LI>Opens a file. 
  <LI>Obtains the access intentions associated with the file descriptor. 
  <LI>Duplicates a file descriptor. 
  <LI>Finds the access intentions associated with the duplicated descriptor. 
  </LI></UL>
<P><PRE>#include &lt;fcntl.h&gt;  /* defines fcntl function and flags */
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt; /* Defines close function */

void fd_mode(int);

int main(int argc, char **argv)
{
  int filedes, newfdes;
 
  if (argc != 2) {
    fprintf(stdout, "format %s filename\n", argv[0]);
    exit(1);
  }
 
  if (( filedes = open(argv[1], O_RDWR | O_APPEND)) == -1)    {
    fprintf(stderr, "open failed\n");
    exit(1);
  }
 
  /* Show the access intentions associated with filedes */

  fd_mode(filedes);

  /* This simply duplicates the file descriptor returning the next free
     number (probably 4) */

  newfdes = fcntl(filedes,F_DUPFD,0); 
 
  /* Show the access intentions associated with newfdes */

  fd_mode(newfdes);
 
  fprintf(stdout,"newfdes = %d\tfiledes = %d\n",newfdes,filedes);

  close(filedes);
  close(newfdes);
  return(0);
}
 
void fd_mode(int fd)
{
  int arg1, dummy;
 
  /* Use fcntl to get the flag attributes associated with the descriptor */

  if ((arg1 = fcntl(fd, F_GETFL, dummy)) == -1) {
    fprintf(stderr,"fcntl failed\n");
    exit(1);
  }
  printf("File Descriptor %d : ", fd);
 
  if (arg1 &amp; O_WRONLY)
    printf("write only");
  else
     if (arg1 &amp; O_RDWR)
       printf("read-write");
     else
       printf("read only");
 
  if(arg1 &amp; O_APPEND)
    printf(" - append flag set");
 
  printf("\n");
}

void:cmk&gt;fcntl_state fcntl_state.c
File Descriptor 3 : read-write - append flag set
File Descriptor 4 : read-write - append flag set
newfdes = 4      filedes = 3
</PRE>The <EM>dup</EM> system call duplicates a file descriptor in the same way 
as a call to <EM>fcntl</EM> using the F_DUPFD flag. <EM>dup</EM> takes as an 
argument a file descriptor <EM>fd</EM>, and returns the lowest numbered 
descriptor not in use which refers to the same object as fd <PRE>int dup(int fd);
int dup2(int fd1, int fd2);
</PRE><EM>dup2</EM> provides more control. In particular, you can specify the 
desired value of the descriptor from the value in fd2. If descriptor fd2 is 
already in use, it is closed and then reopened to refer to the same object as 
fd1 but using fd2's value. fd1 specifies the object to be duplicated. 
<P>The new descriptor has the following in common with the original: 
<UL>
  <LI>It refers to the same object that the old descriptor referred to. 
  <LI>It uses the same file pointer as the old descriptor (that is, both file 
  descriptors share one file pointer). 
  <LI>It has the same access mode (read, write or read/write) as the old 
  descriptor. </LI></UL>
<P>The following program: 
<UL>
  <LI>Duplicates the standard input fd. 
  <LI>Reads a string via the duplicated fd. 
  <LI>Opens a file. 
  <LI>Redirects standard output to the file using dup2. 
  <LI>Writes to standard output, i.e. the data goes to the file. </LI></UL>
<P><PRE>#include &lt;fcntl.h&gt;   /* Definition of flags */
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;  /* Definition of read &amp; dup &amp; dup2 */
#include &lt;stdlib.h&gt;
#define NUM_CHRS 10
 
int main(int argc, char **argv)
{
   int fd1, fd2;
   char *cp;

   cp =  malloc((NUM_CHRS+1) * sizeof(char));

   fd1 = dup(0);        /* duplicated standard in */
 
   printf("enter a string : \n");
   read(fd1, cp, NUM_CHRS);

   printf("fd1 = %d : \tcharacters = %s\n", fd1, cp);

   fd2 = open(argv[1], O_WRONLY);
   dup2(fd2, 1);

   printf("fd2 = %d : \tcharacters = %s\n", fd2, cp);

   return 0;
}
</PRE>
<HR>
<A name=ftw></A>
<H3>Ftw (file tree walking)</H3><EM>ftw</EM> is a library function that 
recursively descends the directory hierarchy. <PRE>#include &lt;ftw.h&gt;
     int ftw(char* path, int (*fn)(), int depth);
</PRE><EM>ftw</EM> descends a directory hierarchy and for each member (file or 
directory) it calls the function <EM>fn</EM> passing to it: 
<OL>
  <LI>A null terminated character string containing the name of the object (file 
  or directory). 
  <LI>A pointer to the <EM>stat</EM> structure associated with the file. 
  <LI>An integer detailing the type of file, see ftw.h. </LI></OL>
<P>The following program descends the path given in the command line argument. 
If no command line argument is given then the program descends starting at the 
current working directory, executing the function list for each member of the 
hierarchy below <EM>path</EM>. The object type is tested to determine if the 
object is a file. <PRE>#include &lt;ftw.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
 
int list(const char *name, const struct stat *status, int type)
{
  if(type == FTW_NS)  /* test for unknown type */
     return(0);
 
   if (type == FTW_F)  /* is it a file */
      printf("%-30s\t0%3lo\n",name,status-&gt;st_mode &amp; 0777);
   else                /* must be something else  put a star by it */
      printf("%-30s*\t0%3lo\n",name,status-&gt;st_mode &amp; 0777);
 
   return(0);
}

int main(int argc, char **argv)
{
   int list();
 
   if(argc &lt;= 1)
     ftw(".",list, 1);
   else
     ftw(argv[1], list, 1);
   return(0);
}
</PRE><EM>ftw</EM> is recursive, it calls itself. Every member in the file tree 
gets traversed once. It uses pre-order traversal, i.e. it executes the 
user-supplied function for the current tree node before traversing to any of its 
children. An example of recursion and directory walking is given below. 
<HR>
<A name=dirfunctions></A>
<H3>Directory functions</H3>There are a collection of functions that operate on 
directories. They provide a more general interface than <EM>ftw</EM>. 
<UL>
  <LI>opendir - opens a directory. 
  <LI>readdir - returns a pointer to the next directory entry. 
  <LI>telldir - returns the location associated with the name directory stream, 
  that is, the position of the directory entry from the start of the directory 
  file. 
  <LI>seekdir - sets the position of the next readdir 
  <LI>rewinddir - resets the position of the directory stream to the start of 
  the directory. This is like an lseek to the start of the directory file. 
  <LI>closedir - closes the named directory stream. </LI></UL>
<P>There is no "writedir" since the system calls mknod, link or open are used 
for this purpose. <PRE>#include &lt;dirent.h&gt;
 
DIR *opendir(char* dirname);
 
struct dirent *readdir(DIR* dirp);
 
long telldir(DIR* dirp);
 
void seekdir(DIR* dirp, long loc);
 
void rewinddir(DIR* dirp);

int closedir(DIR* dirp);
</PRE>The following program walks a directory given as an argument printing out 
the type of each file in the hierarchy. It will descend into child directories 
via the function <EM>walk_dir</EM> calling itself with an argument of the child 
directory it wants to search. <PRE>#include &lt;stdio.h&gt;
#include &lt;dirent.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
 
/* A static global means that the variable is only visible to code 
   in this file */

static int level_limit = 2;   
static int present_level = 1;
void walk_dir(char *);
 
int main(int argc, char **argv)
{
   /* argv[1] should contain the root pathname of the tree to be traversed.
      A real program would analyse the command line args for errors.*/

   walk_dir(argv[1]);
   return 0;
}
 
void walk_dir(char *path)
{
   struct dirent *dp;
   struct stat buf;
   char full_path[80];
   DIR *fd;
 
   if ((fd = opendir(path)) == NULL)     {
      perror("error opening dir %s\n");
      exit(1);
   }
 
   /* Collect directory entries. dp being set to NULL indicates that
      the tree has been fully traversed */

   for (dp = readdir(fd); dp != NULL; dp = readdir(fd))
   {
      /* Concatenate the directory entry onto the existing path.
         Should really check for the special case of path being "/"
         since the current code prints too many "/"s for this case */

      sprintf(full_path,"%s/%s", path, dp-&gt;d_name);

      /* Obtain status information about the file/directory. stat
         may fail if the path refers to a symbolic link which doesn't point
         to a valid destination. In this case we use lstat 
         to get information */

      if((stat(full_path, &amp;buf)) == -1)
      {
         if((lstat(full_path, &amp;buf)) == -1) {
            perror("stat failed");
            exit(2);
         }
      }
      /* Now display the type of the directory entry: symbolic link, 
         file or directory */

      if(S_ISLNK(buf.st_mode))
         printf("%s is a symbolic link\n",full_path);
 
      if (S_ISREG(buf.st_mode))
         printf("%s is a file\n",full_path);
 
      /* If a directory then we recurse. However, we don't won't to go 
         round in circles so don't traverse across the ".." 
         or "." links. */

      if (S_ISDIR(buf.st_mode))  { /* lets do some recursion */
         if (!(strcmp(".", dp-&gt;d_name) == 0 || strcmp("..", dp-&gt;d_name) == 0))
         {
            printf("%s is a directory\n", full_path);

            /* Only recurse if we haven't hit our maximum depth 
               of recursion limit */

            if( present_level &lt; level_limit)
            {
               present_level++;
               walk_dir(full_path);  /* recursion */

               /* Here we drop out of recursion (go up a level in the file
                  tree, so we decrement the level counter */

               present_level--;
            }
         } /* if (!(strcmp */
      } /* if(S_ISDIR */
   } /* for */

   /* This part of the program is contrived, but illustrates the use of
      other directory functions */

   rewinddir(fd); /* Takes us to the start of the directory file */
   printf("location in directory %s is %ld\n", path, telldir(fd));

   seekdir(fd, 2); /* We move entry pointer to second directory entry */
   printf("location in directory %s is %ld\n", path, telldir(fd));

   rewinddir(fd);
   printf("location in directory %s is %ld\n", path, telldir(fd));
   closedir (fd);
}
</PRE></BODY></HTML>
