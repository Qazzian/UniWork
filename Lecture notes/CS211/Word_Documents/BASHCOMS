


User Commands                                             BASH(1)



NAME
     bash - GNU Bourne-Again SHell

SYNOPSIS
     bash [options] [file]

COPYRIGHT
     Bash is Copyright (C) 1989, 1991, 1993, 1995,  1996  by  the
     Free Software Foundation, Inc.

DESCRIPTION
     Bash is an sh-compatible command language  interpreter  that
     executes  commands  read  from  the standard input or from a
     file.  Bash also incorporates useful features from the  _K_o_r_n
     and _C shells (ksh and csh).

     Bash is ultimately intended to be a  conformant  implementa-
     tion  of  the IEEE POSIX Shell and Tools specification (IEEE
     Working Group 1003.2).

OPTIONS
     In addition to the single-character shell options documented
     in  the  description of the set builtin command, bash inter-
     prets the following flags when it is invoked:

     -c _s_t_r_i_n_g If the -c flag is present, then commands are  read
               from  _s_t_r_i_n_g.   If  there  are arguments after the
               _s_t_r_i_n_g, they are assigned to the positional param-
               eters, starting with $0.
     -r        If the -r flag is present, the shell becomes  _r_e_s_-
               _t_r_i_c_t_e_d (see RESTRICTED SHELL below).
     -i        If the -i flag is present, the shell  is  _i_n_t_e_r_a_c_-
               _t_i_v_e.
     -s        If the -s flag is  present,  or  if  no  arguments
               remain  after option processing, then commands are
               read from the standard input.  This option  allows
               the  positional parameters to be set when invoking
               an interactive shell.
     -D        A list of all double-quoted strings preceded by  $
               is  printed  on the standard ouput.  These are the
               strings that are subject to  language  translation
               when  the  current locale is not C or POSIX.  This
               implies the -n option; no commands  will  be  exe-
               cuted.
     --        A -- signals  the  end  of  options  and  disables
               further  option  processing.   Any arguments after
               the -- are treated as filenames and arguments.  An
               argument of - is equivalent to --.

     Bash also interprets a number  of  multi-character  options.
     These  options  must  appear  on the command line before the
     single-character options in order for them to be recognized.



GNU                 Last change: 1996 Nov 25                    1






User Commands                                             BASH(1)



     --dump-strings
          Equivalent to -D.
     --help
          Display a usage message on  standard  output  and  exit
          successfully.
     --login
          Make bash act as if it had  been  invoked  as  a  login
          shell (see INVOCATION below).
     --noediting
          Do not use the GNU readline  library  to  read  command
          lines if interactive.
     --noprofile
          Do  not  read  either  the  system-wide  startup   file
          /_e_t_c/_p_r_o_f_i_l_e  or  any  of  the  personal initialization
          files ~/._b_a_s_h__p_r_o_f_i_l_e,  ~/._b_a_s_h__l_o_g_i_n,  or  ~/._p_r_o_f_i_l_e.
          By  default,  bash reads these files when it is invoked
          as a login shell (see INVOCATION below).
     --norc
          Do not read and  execute  the  personal  initialization
          file  ~/._b_a_s_h_r_c  if  the  shell  is  interactive.  This
          option is on by default if the shell is invoked as sh.
     --posix
          Change the behavior of bash where the default operation
          differs  from  the  POSIX  1003.2 standard to match the
          standard.
     --rcfile _f_i_l_e
          Execute commands from _f_i_l_e instead of the standard per-
          sonal  initialization  file  ~/._b_a_s_h_r_c  if the shell is
          interactive (see INVOCATION below).
     --restricted
          The shell  becomes  restricted  (see  RESTRICTED  SHELL
          below).
     --verbose
          Equivalent to  -v.
     --version
          Show version information for this instance of  bash  on
          the standard output and exit successfully.

ARGUMENTS
     If arguments remain after option processing, and neither the
     -c  nor  the -s option has been supplied, the first argument
     is assumed to be the name of a file  containing  shell  com-
     mands.  If bash is invoked in this fashion, $0 is set to the
     name of the file, and the positional parameters are  set  to
     the  remaining  arguments.  Bash reads and executes commands
     from this file, then exits.  Bash's exit status is the  exit
     status  of  the  last command executed in the script.  If no
     commands are executed, the exit status is 0.

INVOCATION
     A _l_o_g_i_n _s_h_e_l_l is one whose first character of argument  zero
     is a -, or one started with the --login option.



GNU                 Last change: 1996 Nov 25                    2






User Commands                                             BASH(1)



     An _i_n_t_e_r_a_c_t_i_v_e shell is one whose standard input and  output
     are   both   connected   to   terminals  (as  determined  by
     _i_s_a_t_t_y(3)), or one started with the -i option.  PS1  is  set
     and  $-  includes i if bash is interactive, allowing a shell
     script or a startup file to test this state.

     The following paragraphs  describe  how  bash  executes  its
     startup  files.   If  any  of  the files exist but cannot be
     read, bash reports an error.  Tildes are  expanded  in  file
     names as described below under Tilde Expansion in the EXPAN-
     SION section.

     When bash is invoked as a login shell, it  first  reads  and
     executes  commands  from the file /_e_t_c/_p_r_o_f_i_l_e, if that file
     exists.    After   reading   that   file,   it   looks   for
     ~/._b_a_s_h__p_r_o_f_i_l_e,  ~/._b_a_s_h__l_o_g_i_n,  and  ~/._p_r_o_f_i_l_e,  in  that
     order, and reads and executes commands from  the  first  one
     that  exists and is readable.  The --noprofile option may be
     used when the shell is started to inhibit this behavior.

     When a login shell exits, bash reads and  executes  commands
     from the file ~/._b_a_s_h__l_o_g_o_u_t, if it exists.

     When an interactive shell that  is  not  a  login  shell  is
     started, bash reads and executes commands from ~/._b_a_s_h_r_c, if
     that file exists.  This may be inhibited by using the --norc
     option.   The  --rcfile  _f_i_l_e option will force bash to read
     and execute commands from _f_i_l_e instead of ~/._b_a_s_h_r_c.

     When bash is  started  non-interactively,  to  run  a  shell
     script,  for  example, it looks for the variable BASH_ENV in
     the environment, expands its value if it appears there,  and
     uses  the  expanded  value as the name of a file to read and
     execute.  Bash behaves as if the following command were exe-
     cuted:
          if [ -n "$BASH_ENV" ]; then . "$BASH_ENV"; fi
     but the value of the PATH variable is not used to search for
     the file name.

     If bash is invoked with the name sh, it tries to  mimic  the
     startup  behavior of historical versions of sh as closely as
     possible, while conforming to the POSIX  standard  as  well.
     When invoked as a login shell, it first attempts to read and
     execute commands from /_e_t_c/_p_r_o_f_i_l_e and ~/._p_r_o_f_i_l_e,  in  that
     order.   The  --noprofile option may be used to inhibit this
     behavior.  When invoked as an  interactive  shell  with  the
     name  sh, bash looks for the variable ENV, expands its value
     if it is defined, and uses the expanded value as the name of
     a  file  to  read  and execute.  Since a shell invoked as sh
     does not attempt to read and execute commands from any other
     startup  files,  the  --rcfile option has no effect.  A non-
     interactive shell invoked with the name sh does not  attempt



GNU                 Last change: 1996 Nov 25                    3






User Commands                                             BASH(1)



     to  read  any startup files. When invoked as sh, bash enters
     _p_o_s_i_x mode after the startup files are read.

     When bash is started in _p_o_s_i_x mode, as with the --posix com-
     mand  line option, it follows the POSIX standard for startup
     files.  In this mode, the ENV variable is expanded and  com-
     mands  are read and executed from the file whose name is the
     expanded value.  No other startup files are read.   This  is
     done by interactive shells only.

     Bash attempts to determine when  it  is  being  run  by  the
     remote shell daemon, usually _r_s_h_d.  If bash determines it is
     being run by _r_s_h_d,  it  reads  and  executes  commands  from
     ~/._b_a_s_h_r_c, if that file exists and is readable.  It will not
     do this if invoked as sh.  The --norc option may be used  to
     inhibit  this  behavior, and the --rcfile option may be used
     to force another file to be read, but  _r_s_h_d  does  not  gen-
     erally  invoke the shell with those options or allow them to
     be specified.

DEFINITIONS
     The following definitions are used throughout  the  rest  of
     this document.
     blank
          A space or tab.
     word A sequence of characters considered as a single unit by
          the shell.  Also known as a token.
     name A _w_o_r_d consisting only of alphanumeric  characters  and
          underscores, and beginning with an alphabetic character
          or an underscore.  Also referred to as an identifier.
     metacharacter
          A character that, when unquoted, separates words.   One
          of the following:
          |  & ; ( ) < > space tab
     control operator
          A _t_o_k_e_n that performs a control function.  It is one of
          the following symbols:
          || & && ; ;; ( ) | <newline>

RESERVED WORDS
     _R_e_s_e_r_v_e_d _w_o_r_d_s are words that have a special meaning to  the
     shell.   The following words are recognized as reserved when
     unquoted and either the first word of a simple command  (see
     SHELL GRAMMAR below) or the third word of a case or for com-
     mand:

     ! case  do done elif else esac fi for function if in  select
     then until while { } time

SHELL GRAMMAR
  Simple Commands




GNU                 Last change: 1996 Nov 25                    4






User Commands                                             BASH(1)



     A _s_i_m_p_l_e _c_o_m_m_a_n_d is a sequence of optional variable  assign-
     ments  followed  by  blank-separated words and redirections,
     and terminated by a _c_o_n_t_r_o_l _o_p_e_r_a_t_o_r.  The first word speci-
     fies  the  command  to be executed.  The remaining words are
     passed as arguments to the invoked command.

     The return value of a _s_i_m_p_l_e _c_o_m_m_a_n_d is its exit status,  or
     128+_n if the command is terminated by signal _n.

  Pipelines
     A _p_i_p_e_l_i_n_e is a sequence of one or more  commands  separated
     by the character |.  The format for a pipeline is:

          [time [-p]] [ ! ] _c_o_m_m_a_n_d [ | _c_o_m_m_a_n_d_2 ... ]

     The standard output of _c_o_m_m_a_n_d is connected to the  standard
     input  of _c_o_m_m_a_n_d_2.  This connection is performed before any
     redirections  specified  by  the  command  (see  REDIRECTION
     below).

     If the reserved word ! precedes a pipeline, the exit  status
     of  that  pipeline  is the logical NOT of the exit status of
     the last command.  Otherwise, the status of the pipeline  is
     the  exit  status  of the last command.  The shell waits for
     all commands in the pipeline to terminate before returning a
     value.

     If the time reserved word precedes a pipeline,  the  elapsed
     as  well  as  user and system time consumed by its execution
     are reported when the pipeline terminates.   The  -p  option
     changes  the  output format to that specified by POSIX.  The
     TIMEFORMAT variable may be  set  to  a  format  string  that
     specifies  how  the  timing information should be displayed;
     see the description  of  TIMEFORMAT  under  Shell  Variables
     below.

     Each command in a pipeline is executed as a separate process
     (i.e., in a subshell).

  Lists
     A _l_i_s_t is a sequence of one or more pipelines  separated  by
     one  of  the  operators ;, &, &&, or ||, and optionally ter-
     minated by one of ;, &, or <newline>.

     Of these list operators, && and ||  have  equal  precedence,
     followed by ; and &, which have equal precedence.

     If a command is terminated by the control  operator  &,  the
     shell  executes the command in the _b_a_c_k_g_r_o_u_n_d in a subshell.
     The shell does not wait for the command to finish,  and  the
     return  status is 0.  Commands separated by a ; are executed
     sequentially; the shell waits for each command to  terminate



GNU                 Last change: 1996 Nov 25                    5






User Commands                                             BASH(1)



     in  turn.   The return status is the exit status of the last
     command executed.

     The control operators && and ||  denote  AND  lists  and  OR
     lists, respectively.  An AND list has the form

          _c_o_m_m_a_n_d && _c_o_m_m_a_n_d_2

     _c_o_m_m_a_n_d_2 is executed if, and only  if,  _c_o_m_m_a_n_d  returns  an
     exit status of zero.

     An OR list has the form

          _c_o_m_m_a_n_d || _c_o_m_m_a_n_d_2

     _c_o_m_m_a_n_d_2 is executed if and only if _c_o_m_m_a_n_d returns  a  non-
     zero  exit status.  The return status of AND and OR lists is
     the exit status of the last command executed in the list.

  Compound Commands
     A _c_o_m_p_o_u_n_d _c_o_m_m_a_n_d is one of the following:

     (_l_i_s_t)
          _l_i_s_t is executed in a subshell.   Variable  assignments
          and  builtin  commands that affect the shell's environ-
          ment do not remain in effect  after  the  command  com-
          pletes.  The return status is the exit status of _l_i_s_t.

     { _l_i_s_t; }
          _l_i_s_t is simply executed in the current  shell  environ-
          ment.   _l_i_s_t must be terminated with a newline or semi-
          colon.  This is known as a _g_r_o_u_p _c_o_m_m_a_n_d.   The  return
          status is the exit status of _l_i_s_t.

     ((_e_x_p_r_e_s_s_i_o_n))
          The _e_x_p_r_e_s_s_i_o_n is  evaluated  according  to  the  rules
          described  below  under  ARITHMETIC EVALUATION.  If the
          value of the expression is non-zero, the return  status
          is  0;  otherwise  the  return  status  is  1.  This is
          exactly equivalent to let "_e_x_p_r_e_s_s_i_o_n".

     for _n_a_m_e [ in _w_o_r_d; ] do _l_i_s_t ; done
          The list of words following in is expanded,  generating
          a list of items.  The variable _n_a_m_e is set to each ele-
          ment of this list in turn, and _l_i_s_t  is  executed  each
          time.   If the in _w_o_r_d is omitted, the for command exe-
          cutes _l_i_s_t once for each positional parameter  that  is
          set (see PARAMETERS below).

     select _n_a_m_e [ in _w_o_r_d; ] do _l_i_s_t ; done
          The list of words following in is expanded,  generating
          a  list of items.  The set of expanded words is printed



GNU                 Last change: 1996 Nov 25                    6






User Commands                                             BASH(1)



          on the standard error, each preceded by a  number.   If
          the  in  _w_o_r_d is omitted, the positional parameters are
          printed (see PARAMETERS below).  The PS3 prompt is then
          displayed  and a line read from the standard input.  If
          the line consists of a number corresponding to  one  of
          the  displayed  words, then the value of _n_a_m_e is set to
          that word.  If the line is empty, the words and  prompt
          are  displayed again.  If EOF is read, the command com-
          pletes.  Any other value read causes _n_a_m_e to be set  to
          null.   The  line  read is saved in the variable REPLY.
          The _l_i_s_t is executed after each selection until a break
          or  return  command  is  executed.   The exit status of
          select is the exit status of the last command  executed
          in _l_i_s_t, or zero if no commands were executed.

     case _w_o_r_d in [ _p_a_t_t_e_r_n [ | _p_a_t_t_e_r_n ] ... ) _l_i_s_t ;; ] ... esac
          A  case  command first expands _w_o_r_d, and tries to match
          it against each _p_a_t_t_e_r_n in turn, using the same  match-
          ing  rules  as  for  pathname  expansion  (see Pathname
          Expansion  below).   When  a  match   is   found,   the
          corresponding _l_i_s_t is executed.  After the first match,
          no subsequent matches are attempted.  The  exit  status
          is  zero  if  no pattern matches.  Otherwise, it is the
          exit status of the last command executed in _l_i_s_t.

fi
     if _l_i_s_t; then _l_i_s_t; [ elif _l_i_s_t; then _l_i_s_t; ] ... [ else _l_i_s_t;  ]
          The  if  _l_i_s_t is executed.  If its exit status is zero,
          the then _l_i_s_t is executed.  Otherwise, each  elif  _l_i_s_t
          is  executed  in  turn, and if its exit status is zero,
          the corresponding then _l_i_s_t is executed and the command
          completes.   Otherwise,  the  else _l_i_s_t is executed, if
          present.  The exit status is the  exit  status  of  the
          last  command  executed, or zero if no condition tested
          true.

     while _l_i_s_t; do _l_i_s_t; done
     until _l_i_s_t; do _l_i_s_t; done
          The while command continuously executes the do _l_i_s_t  as
          long as the last command in _l_i_s_t returns an exit status
          of zero.  The until command is identical to  the  while
          command,  except  that the test is negated; the do _l_i_s_t
          is executed as long as the last command in _l_i_s_t returns
          a  non-zero  exit status.  The exit status of the while
          and until commands is the exit status of  the  last  do
          _l_i_s_t command executed, or zero if none was executed.

     [ function ] _n_a_m_e () { _l_i_s_t; }
          This defines a function named _n_a_m_e.  The  _b_o_d_y  of  the
          function is the _l_i_s_t of commands between { and }.  This
          list is executed whenever _n_a_m_e is specified as the name
          of  a simple command.  The exit status of a function is



GNU                 Last change: 1996 Nov 25                    7






User Commands                                             BASH(1)



          the exit status of the last  command  executed  in  the
          body.  (See FUNCTIONS below.)

COMMENTS
     In a non-interactive shell, or an interactive shell in which
     the  interactive_comments  option  to  the  shopt builtin is
     enabled (see SHELL BUILTIN COMMANDS below), a word beginning
     with # causes that word and all remaining characters on that
     line to  be  ignored.   An  interactive  shell  without  the
     interactive_comments  shopt  option  enabled  does not allow
     comments.  The interactive_comments option is on by  default
     in interactive shells.

QUOTING
     _Q_u_o_t_i_n_g is used to remove the  special  meaning  of  certain
     characters  or  words  to the shell.  Quoting can be used to
     disable special treatment for special characters, to prevent
     reserved words from being recognized as such, and to prevent
     parameter expansion.

     Each of the _m_e_t_a_c_h_a_r_a_c_t_e_r_s listed  above  under  DEFINITIONS
     has  special meaning to the shell and must be quoted if they
     are  to  represent  themselves.   There  are  three  quoting
     mechanisms:  the _e_s_c_a_p_e _c_h_a_r_a_c_t_e_r, single quotes, and double
     quotes.

     A non-quoted backslash (\)  is  the  _e_s_c_a_p_e  _c_h_a_r_a_c_t_e_r.   It
     preserves  the literal value of the next character that fol-
     lows, with the exception of <newline>.  If a \<newline> pair
     appears,  and the backslash is not quoted, the \<newline> is
     treated as a line continuation (that is, it  is  effectively
     ignored).

     Enclosing characters in single quotes preserves the  literal
     value  of  each character within the quotes.  A single quote
     may not occur between single quotes, even when preceded by a
     backslash.

     Enclosing characters in double quotes preserves the  literal
     value  of  all characters within the quotes, with the excep-
     tion of $, `, and \.  The characters $ and  `  retain  their
     special meaning within double quotes.  The backslash retains
     its special meaning only when followed by one of the follow-
     ing  characters:   $, `, ", \, or <newline>.  A double quote
     may be quoted within double quotes by preceding  it  with  a
     backslash.

     The special parameters * and @ have special meaning when  in
     double quotes (see PARAMETERS below).

     Words of the form $'_s_t_r_i_n_g' are treated specially.  The word
     expands   to   _s_t_r_i_n_g,   with  backslash-escaped  characters



GNU                 Last change: 1996 Nov 25                    8






User Commands                                             BASH(1)



     replaced as specifed by  the  ANSI  C  standard.   Backslash
     escape sequences, if present, are decoded as follows:
          \a   alert (bell)
          \b   backspace
          \e   an escape character
          \f   form feed
          \n   new line
          \r   carriage return
          \t   horizontal tab
          \v   vertical tab
          \\   backslash
          \_n_n_n the character whose ASCII code is _n_n_n (octal)

     The translated result is single-quoted,  as  if  the  dollar
     sign had not been present.

     A double-quoted string preceded by a dollar  sign  ($)  will
     cause  the  string to be translated according to the current
     locale.  If the current locale is C  or  POSIX,  the  dollar
     sign  is ignored.  If the string is translated and replaced,
     the replacement is double-quoted.

PARAMETERS
     A _p_a_r_a_m_e_t_e_r is an entity that stores values.  It  can  be  a
     _n_a_m_e,  a  number,  or  one  of the special characters listed
     below under Special Parameters.  For the shell's purposes, a
     _v_a_r_i_a_b_l_e is a parameter denoted by a _n_a_m_e.

     A parameter is set if it has been  assigned  a  value.   The
     null  string  is  a valid value.  Once a variable is set, it
     may be unset only by using the unset  builtin  command  (see
     SHELL BUILTIN COMMANDS below).

     A _v_a_r_i_a_b_l_e may be assigned to by a statement of the form

          _n_a_m_e=[_v_a_l_u_e]

     If _v_a_l_u_e is not given, the variable  is  assigned  the  null
     string.   All  _v_a_l_u_e_s undergo tilde expansion, parameter and
     variable expansion, string expansion, command  substitution,
     arithmetic  expansion,  and  quote  removal  (see  EXPANSION
     below).  If the variable  has  its  -i  attribute  set  (see
     declare  below in SHELL BUILTIN COMMANDS) then _v_a_l_u_e is sub-
     ject to arithmetic expansion even  if  the  $((...))  syntax
     does  not  appear  (see  Arithmetic  Expansion below).  Word
     splitting is not performed, with the exception  of  "$@"  as
     explained  below  under Special Parameters.  Pathname expan-
     sion is not performed.

  Positional Parameters
     A _p_o_s_i_t_i_o_n_a_l _p_a_r_a_m_e_t_e_r is a parameter denoted by one or more
     digits,   other   than   the  single  digit  0.   Positional



GNU                 Last change: 1996 Nov 25                    9






User Commands                                             BASH(1)



     parameters are assigned from the shell's arguments  when  it
     is invoked, and may be reassigned using the set builtin com-
     mand.  Positional parameters may not  be  assigned  to  with
     assignment  statements.   The positional parameters are tem-
     porarily replaced when a shell  function  is  executed  (see
     FUNCTIONS below).

     When a positional parameter consisting of more than a single
     digit is expanded, it must be enclosed in braces (see EXPAN-
     SION below).

  Special Parameters
     The shell treats several parameters specially.  These param-
     eters  may  only  be  referenced;  assignment to them is not
     allowed.
     *    Expands to the  positional  parameters,  starting  from
          one.   When  the expansion occurs within double quotes,
          it expands to a single word  with  the  value  of  each
          parameter  separated  by the first character of the IFS
          special variable.  That is,  ``$*''  is  equivalent  to
          ``$1_c$2_c...'',  where  _c  is the first character of the
          value of the IFS variable.  If IFS is  null  or  unset,
          the parameters are separated by spaces.
     @    Expands to the  positional  parameters,  starting  from
          one.   When  the expansion occurs within double quotes,
          each parameter expands as a separate word.  That is, ``
          $@'' is equivalent to ``$1'' ``$2'' ...  When there are
          no positional parameters, ``$@'' and $@ expand to noth-
          ing (i.e., they are removed).
     #    Expands to  the  number  of  positional  parameters  in
          decimal.
     ?    Expands to the status of  the  most  recently  executed
          foreground pipeline.
     -    Expands to the current option flags as  specified  upon
          invocation, by the set builtin command, or those set by
          the shell itself (such as the -i flag).
     $    Expands to the process ID of the shell.  In a  ()  sub-
          shell,  it  expands  to  the  process ID of the current
          shell, not the subshell.
     !    Expands to the process ID of the most recently executed
          background (asynchronous) command.
     0    Expands to the name of the shell or shell script.  This
          is  set  at  shell  initialization.  If bash is invoked
          with a file of commands, $0 is set to the name of  that
          file.   If  bash is started with the -c option, then $0
          is set to the first argument after  the  string  to  be
          executed,  if  one is present.  Otherwise, it is set to
          the file name used to invoke bash, as given by argument
          zero.
     _    At shell startup, set to the absolute file name of  the
          shell  or  shell script being executed as passed in the
          argument  list.   Subsequently,  expands  to  the  last



GNU                 Last change: 1996 Nov 25                   10






User Commands                                             BASH(1)



          argument  to  the  previous  command,  after expansion.
          Also set to the full file name of each command executed
          and placed in the environment exported to that command.
          When checking mail, this parameter holds  the  name  of
          the mail file currently being checked.

  Shell Variables
     The following variables are set by the shell:

     PPID The process ID of the shell's parent.
     PWD  The current working directory as set by the cd command.
     OLDPWD
          The previous working directory as set by  the  cd  com-
          mand.
     REPLY
          Set to the line of input read by the read builtin  com-
          mand when no arguments are supplied.
     UID  Expands to the user ID of the current user, initialized
          at shell startup.
     EUID Expands to the effective user ID of the  current  user,
          initialized at shell startup.
     BASH Expands to the full  file  name  used  to  invoke  this
          instance of bash.
     BASH_VERSION
          Expands to a string  describing  the  version  of  this
          instance of bash.
     BASH_VERSINFO
          An array variable whose members hold  version  informa-
          tion for this instance of bash.  The values assigned to
          the array members are as follows:
          BASH_VERSINFO[0]        The major version  number  (the
                                  _r_e_l_e_a_s_e).
          BASH_VERSINFO[1]        The minor version  number  (the
                                  _v_e_r_s_i_o_n).
          BASH_VERSINFO[2]        The patch level.
          BASH_VERSINFO[3]        The build version.
          BASH_VERSINFO[4]        The   release   status   (e.g.,
                                  _b_e_t_a_1).
          BASH_VERSINFO[5]        The value of MACHTYPE.

     SHLVL
          Incremented by one each time an  instance  of  bash  is
          started.

     RANDOM
          Each  time  this  parameter  is  referenced,  a  random
          integer between 0 and 32767 is generated.  The sequence
          of random numbers may be  initialized  by  assigning  a
          value to RANDOM.  If RANDOM is unset, it loses its spe-
          cial properties, even if it is subsequently reset.

     SECONDS



GNU                 Last change: 1996 Nov 25                   11






User Commands                                             BASH(1)



          Each time this parameter is referenced, the  number  of
          seconds since shell invocation is returned.  If a value
          is assigned to SECONDS, the value returned upon  subse-
          quent  references  is  the  number of seconds since the
          assignment plus the  value  assigned.   If  SECONDS  is
          unset,  it  loses its special properties, even if it is
          subsequently reset.

     LINENO
          Each time this parameter is referenced, the shell  sub-
          stitutes  a  decimal  number  representing  the current
          sequential line  number  (starting  with  1)  within  a
          script  or function.  When not in a script or function,
          the value substituted is not guaranteed to be  meaning-
          ful.   If LINENO is unset, it loses its special proper-
          ties, even if it is subsequently reset.

     HISTCMD
          The history number, or index in the  history  list,  of
          the current command.  If HISTCMD is unset, it loses its
          special properties, even if it is subsequently reset.

     DIRSTACK
          An array variable (see  Arrays  below)  containing  the
          current  contents  of the directory stack.  Directories
          appear in the stack in the order they are displayed  by
          the  dirs  builtin.  Assigning to members of this array
          variable may be used to modify directories  already  in
          the stack, but the pushd and popd builtins must be used
          to add and  remove  directories.   Assignment  to  this
          variable  will  not  change  the current directory.  If
          DIRSTACK is unset, it  loses  its  special  properties,
          even if it is subsequently reset.

     PIPESTATUS
          An array variable (see Arrays below) containing a  list
          of  exit  status values from the processes in the most-
          recently-executed foreground pipeline (which  may  con-
          tain only a single command).

     OPTARG
          The value of the last option argument processed by  the
          getopts  builtin  command  (see  SHELL BUILTIN COMMANDS
          below).

     OPTIND
          The index of the next argument to be processed  by  the
          getopts  builtin  command  (see  SHELL BUILTIN COMMANDS
          below).

     HOSTNAME
          Automatically set to the name of the current host.



GNU                 Last change: 1996 Nov 25                   12






User Commands                                             BASH(1)



     HOSTTYPE
          Automatically set to a string that  uniquely  describes
          the  type  of  machine on which bash is executing.  The
          default is system-dependent.

     OSTYPE
          Automatically  set  to  a  string  that  describes  the
          operating  system  on  which  bash  is  executing.  The
          default is system-dependent.

     MACHTYPE
          Automatically set to a string that fully describes  the
          system type on which bash is executing, in the standard
          GNU _c_p_u-_c_o_m_p_a_n_y-_s_y_s_t_e_m format.  The default is  system-
          dependent.

     SHELLOPTS
          A colon-separated list of enabled shell options.   Each
          word  in the list is a valid argument for the -o option
          to the set builtin command (see SHELL BUILTIN  COMMANDS
          below).   The  options appearing in SHELLOPTS are those
          reported as _o_n by set -o.  If this variable is  in  the
          environment  when  bash starts up, each shell option in
          the list will be enabled  before  reading  any  startup
          files.  This variable is read-only.

     The following variables are used  by  the  shell.   In  some
     cases,  bash  assigns  a  default value to a variable; these
     cases are noted below.

     IFS  The _I_n_t_e_r_n_a_l _F_i_e_l_d _S_e_p_a_r_a_t_o_r  that  is  used  for  word
          splitting after expansion and to split lines into words
          with the read builtin command.  The  default  value  is
          ``<space><tab><newline>''.
     PATH The search path for commands.  It is a  colon-separated
          list  of  directories in which the shell looks for com-
          mands (see COMMAND EXECUTION below).  The default  path
          is  system-dependent,  and  is set by the administrator
          who    installs    bash.     A    common    value    is
          ``/usr/gnu/bin:/usr/local/bin:/usr/ucb:/bin:/usr/bin:.''.
     HOME The home directory of the  current  user;  the  default
          argument for the cd builtin command.
     CDPATH
          The search path for the cd command.  This is  a  colon-
          separated  list of directories in which the shell looks
          for destination directories specified by  the  cd  com-
          mand.  A sample value is ``.:~:/usr''.
     ENV  If this parameter is set when bash is executing a shell
          script, its value is interpreted as a filename contain-
          ing commands to initialize the shell,  as  in  ._b_a_s_h_r_c.
          The  value  of ENV is subjected to parameter expansion,
          command substitution, and arithmetic  expansion  before



GNU                 Last change: 1996 Nov 25                   13






User Commands                                             BASH(1)



          being  interpreted as a file name.  PATH is not used to
          search for the resultant file name.
     MAIL If this parameter is set to a file name and  the  MAIL-
          PATH  variable is not set, bash informs the user of the
          arrival of mail in the specified file.
     MAILCHECK
          Specifies how often (in seconds) bash checks for  mail.
          The  default  is  60 seconds.  When it is time to check
          for mail, the shell does so before displaying the  pri-
          mary prompt.  If this variable is unset, the shell dis-
          ables mail checking.
     MAILPATH
          A colon-separated list of file names to be checked  for
          mail.  The  message  to  be printed may be specified by
          separating the file name from the message with  a  `?'.
          $_  stands  for the name of the current mailfile. Exam-
          ple:
          MAILPATH='/usr/spool/mail/bfox?"You                have
          mail":~/shell-mail?"$_ has mail!"'
          Bash supplies a default value for  this  variable,  but
          the  location  of  the  user mail files that it uses is
          system dependent (e.g., /usr/spool/mail/$USER).
     PS1  The value of this parameter is expanded (see  PROMPTING
          below)  and  used  as  the  primary prompt string.  The
          default value is ``\s-\v\$ ''.
     PS2  The value of this parameter is expanded as with PS1 and
          used  as  the  secondary prompt string.  The default is
          ``> ''.
     PS3  The value of this parameter is used as the  prompt  for
          the select command (see SHELL GRAMMAR above).
     PS4  The value of this parameter is expanded as with PS1 and
          the  value is printed before each command bash displays
          during an execution trace.  The first character of  PS4
          is replicated multiple times, as necessary, to indicate
          multiple levels of indirection.  The default is ``+ ''.
     TIMEFORMAT
          The value of this parameter is used as a format  string
          specifying  how  the  timing  information for pipelines
          prefixed  with  the  time  reserved  word   should   be
          displayed.    The  %  character  introduces  an  escape
          sequence that is expanded to  a  time  value  or  other
          information.   The  escape sequences and their meanings
          are as follows; the braces denote optional portions.
          %%        A literal %.
          %[_p][l]R  The elapsed time in seconds.
          %[_p][l]U  The number of CPU seconds spent in user mode.
          %[_p][l]S  The number of CPU  seconds  spent  in  system
                    mode.
          %P        The CPU percentage, computed as (%U +  %S)  /
                    %R.

          The optional _p is a digit specifying the _p_r_e_c_i_s_i_o_n, the



GNU                 Last change: 1996 Nov 25                   14






User Commands                                             BASH(1)



          number  of  fractional digits after a decimal point.  A
          value of 0 causes no decimal point or  fraction  to  be
          output.   At  most three places after the decimal point
          may be specified;  values  of  _p  greater  than  3  are
          changed  to  3.   If _p is not specified, the value 3 is
          used.

          The optional l specifies  a  longer  format,  including
          minutes,  of the form _M_Mm_S_S._F_Fs.  The value of _p deter-
          mines whether or not the fraction is included.

          If this variable is not set, bash acts as if it had the
          value   $'\nreal\t%3lR\nuser\t%3lU\nsys%3lS'.   If  the
          value is null, no timing information is  displayed.   A
          trailing  newline  is  added  when the format string is
          displayed.

     HISTSIZE
          The number of commands to remember in the command  his-
          tory (see HISTORY below).  The default value is 500.

     HISTFILE
          The name of the file in which command history is  saved
          (see    HISTORY   below).    The   default   value   is
          ~/._b_a_s_h__h_i_s_t_o_r_y.  If unset, the command history is  not
          saved when an interactive shell exits.

     HISTFILESIZE
          The maximum number of lines contained  in  the  history
          file.  When this variable is assigned a value, the his-
          tory file is truncated, if  necessary,  to  contain  no
          more  than  that number of lines.  The default value is
          500.  The history file is also truncated to  this  size
          after writing it when an interactive shell exits.

     OPTERR
          If set to the value 1,  bash  displays  error  messages
          generated  by  the  getopts  builtin command (see SHELL
          BUILTIN COMMANDS below).  OPTERR is  initialized  to  1
          each  time  the  shell  is invoked or a shell script is
          executed.

     LANG Used to determine the locale category for any  category
          not specifically selected with a variable starting with
          LC_.

     LC_ALL
          This variable overrides the value of LANG and any other
          LC_ variable specifying a locale category.

     LC_COLLATE
          This variable determines the collation order used  when



GNU                 Last change: 1996 Nov 25                   15






User Commands                                             BASH(1)



          sorting the results of pathname expansion.

     LC_MESSAGES
          This variable determines the locale used  to  translate
          double-quoted strings preceded by a $.

     PROMPT_COMMAND
          If set, the value is executed as  a  command  prior  to
          issuing each primary prompt.

     IGNOREEOF
          Controls the action of an interactive shell on  receipt
          of  an  EOF  character  as the sole input.  If set, the
          value is the number of consecutive EOF characters which
          must  be typed as the first characters on an input line
          before bash exits.  If the variable exists but does not
          have  a  numeric  value,  or  has no value, the default
          value is 10.  If it does not exist, EOF  signifies  the
          end of input to the shell.

     TMOUT
          If set to a value  greater  than  zero,  the  value  is
          interpreted  as the number of seconds to wait for input
          after issuing  the  primary  prompt.   Bash  terminates
          after  waiting for that number of seconds if input does
          not arrive.

     FCEDIT
          The default editor for the fc builtin command.

     FIGNORE
          A colon-separated list of suffixes to ignore when  per-
          forming  filename  completion  (see READLINE below).  A
          filename whose suffix matches one  of  the  entries  in
          FIGNORE is excluded from the list of matched filenames.
          A sample value is ``.o:~''.

     GLOBIGNORE
          A colon-separated list of patterns defining the set  of
          filenames  to  be  ignored by pathname expansion.  If a
          filename matched by a pathname expansion  pattern  also
          matches  one  of  the  patterns  in  GLOBIGNORE,  it is
          removed from the list of matches.

     INPUTRC
          The filename for the readline startup file,  overriding
          the default of ~/._i_n_p_u_t_r_c (see READLINE below).

     HISTCONTROL
          If set to a value of  _i_g_n_o_r_e_s_p_a_c_e,  lines  which  begin
          with  a  space character are not entered on the history
          list.  If set to a value of _i_g_n_o_r_e_d_u_p_s, lines  matching



GNU                 Last change: 1996 Nov 25                   16






User Commands                                             BASH(1)



          the  last  history  line  are  not entered.  A value of
          _i_g_n_o_r_e_b_o_t_h combines the two options.  If unset,  or  if
          set to any other value than those above, all lines read
          by the parser are saved on the history list, subject to
          the  value  of HISTIGNORE.  This variable's function is
          superseded by HISTIGNORE.

     HISTIGNORE
          A colon-separated list of patterns used to decide which
          command  lines  should  be  saved  on the history list.
          Each pattern is anchored at the beginning of  the  line
          and  must  fully  specify  the line (no implicit `*' is
          appended).  Each pattern is  tested  against  the  line
          after  the checks specified by HISTCONTROL are applied.
          In addition to the normal shell pattern matching  char-
          acters, `&' matches the previous history line.  `&' may
          be escaped using a backslash.  The backslash is removed
          before attempting a match.

     histchars
          The two  or  three  characters  which  control  history
          expansion   and  tokenization  (see  HISTORY  EXPANSION
          below).  The first character is the  _h_i_s_t_o_r_y  _e_x_p_a_n_s_i_o_n
          _c_h_a_r_a_c_t_e_r,  that  is,  the  character which signals the
          start of a history expansion, normally `!'.  The second
          character is the _q_u_i_c_k _s_u_b_s_t_i_t_u_t_i_o_n character, which is
          used as shorthand for re-running the  previous  command
          entered,  substituting  one  string  for another in the
          command.  The default is `^'.  The optional third char-
          acter   is  the  character  which  signifies  that  the
          remainder of the line is a comment when  found  as  the
          first  character  of a word, normally `#'.  The history
          comment character causes  history  substitution  to  be
          skipped  for  the remaining words on the line.  It does
          not necessarily cause the shell  parser  to  treat  the
          rest of the line as a comment.

     HOSTFILE
          Contains the name of a  file  in  the  same  format  as
          /_e_t_c/_h_o_s_t_s  that should be read when the shell needs to
          complete a hostname.  The file may be changed  interac-
          tively;  the next time hostname completion is attempted
          bash adds the contents of the new file to  the  already
          existing database.

     auto_resume
          This variable controls how the shell interacts with the
          user  and job control.  If this variable is set, single
          word simple commands without redirections  are  treated
          as  candidates  for  resumption  of an existing stopped
          job.  There is no ambiguity allowed; if there  is  more
          than  one  job beginning with the string typed, the job



GNU                 Last change: 1996 Nov 25                   17






User Commands                                             BASH(1)



          most recently accessed is  selected.   The  _n_a_m_e  of  a
          stopped  job, in this context, is the command line used
          to start it.  If set to the  value  _e_x_a_c_t,  the  string
          supplied  must match the name of a stopped job exactly;
          if set to _s_u_b_s_t_r_i_n_g, the string supplied needs to match
          a  substring  of  the  name of a stopped job.  The _s_u_b_-
          _s_t_r_i_n_g value provides functionality analogous to the %?
          job  identifier (see JOB CONTROL below).  If set to any
          other value, the supplied string must be a prefix of  a
          stopped  job's name; this provides functionality analo-
          gous to the % job identifier.

  Arrays
     Bash provides one-dimensional array variables.  Any variable
     may be used as an array; the declare builtin will explicitly
     declare an array.  There is no maximum limit on the size  of
     an  array,  nor  any  requirement that members be indexed or
     assigned contiguously.  Arrays are  indexed  using  integers
     and are zero-based.

     An  array  is  created  automatically  if  any  variable  is
     assigned  to  using  the  syntax _n_a_m_e[_s_u_b_s_c_r_i_p_t]=_v_a_l_u_e.  The
     _s_u_b_s_c_r_i_p_t is treated as an arithmetic expression  that  must
     evaluate  to  a  number  greater  than or equal to zero.  To
     explicitly declare an array, use declare -a _n_a_m_e (see  SHELL
     BUILTIN COMMANDS below).  declare -a _n_a_m_e[_s_u_b_s_c_r_i_p_t] is also
     accepted; the  _s_u_b_s_c_r_i_p_t  is  ignored.   Attributes  may  be
     specified  for  an  array  variable  using  the  declare and
     readonly builtins.  Each attribute applies to all members of
     an array.

     Arrays are assigned to using  compound  assignments  of  the
     form  _n_a_m_e=(value_1  ...  value_n), where each _v_a_l_u_e is of the
     form [_s_u_b_s_c_r_i_p_t]=_s_t_r_i_n_g.  Only _s_t_r_i_n_g is required.   If  the
     optional  brackets and subscript are supplied, that index is
     assigned to; otherwise the index of the element assigned  is
     the  last  index  assigned  to  by  the  statement plus one.
     Indexing starts at zero.  This syntax is  also  accepted  by
     the  declare  builtin.   Individual  array  elements  may be
     assigned to using the  _n_a_m_e[_s_u_b_s_c_r_i_p_t]=_v_a_l_u_e  syntax  intro-
     duced above.

     Any  element  of  an   array   may   be   referenced   using
     ${_n_a_m_e[_s_u_b_s_c_r_i_p_t]}.   The  braces are required to avoid con-
     flicts with pathname expansion.  If _s_u_b_s_c_r_i_p_t is @ or *, the
     word  expands  to  all  members  of  _n_a_m_e.  These subscripts
     differ only when the word appears within double quotes.   If
     the  word  is  double-quoted, ${_n_a_m_e[*]} expands to a single
     word with the value of each array member  separated  by  the
     first  character of the IFS special variable, and ${_n_a_m_e[@]}
     expands each element of _n_a_m_e to a separate word.  When there
     are  no  array members, ${_n_a_m_e[@]} expands to nothing.  This



GNU                 Last change: 1996 Nov 25                   18






User Commands                                             BASH(1)



     is analogous to the expansion of the  special  parameters  *
     and  @  (see Special Parameters above).  ${#_n_a_m_e[_s_u_b_s_c_r_i_p_t]}
     expands to the length of ${_n_a_m_e[_s_u_b_s_c_r_i_p_t]}.   If  _s_u_b_s_c_r_i_p_t
     is  *  or  @, the expansion is the number of elements in the
     array.  Referencing an array variable without a subscript is
     equivalent to referencing element zero.

     The  unset  builtin  is  used  to  destroy  arrays.    unset
     _n_a_m_e[_s_u_b_s_c_r_i_p_t]  destroys  the  array  element at index _s_u_b_-
     _s_c_r_i_p_t.  unset _n_a_m_e,  where  _n_a_m_e  is  an  array,  or  unset
     _n_a_m_e[_s_u_b_s_c_r_i_p_t],  where  _s_u_b_s_c_r_i_p_t  is  *  or @, removes the
     entire array.

     The declare, local, and readonly builtins each accept  a  -a
     option  to  specify an array.  The read builtin accepts a -a
     option to assign a list of  words  read  from  the  standard
     input  to  an  array.   The set and declare builtins display
     array values in a way that  allows  them  to  be  reused  as
     assignments.

EXPANSION
     Expansion is performed on the command line after it has been
     split  into  words.  There are seven kinds of expansion per-
     formed:  _b_r_a_c_e _e_x_p_a_n_s_i_o_n,  _t_i_l_d_e  _e_x_p_a_n_s_i_o_n,  _p_a_r_a_m_e_t_e_r  _a_n_d
     _v_a_r_i_a_b_l_e  _e_x_p_a_n_s_i_o_n, _c_o_m_m_a_n_d _s_u_b_s_t_i_t_u_t_i_o_n, _a_r_i_t_h_m_e_t_i_c _e_x_p_a_n_-
     _s_i_o_n, _w_o_r_d _s_p_l_i_t_t_i_n_g, and _p_a_t_h_n_a_m_e _e_x_p_a_n_s_i_o_n.

     The order of expansions is: brace  expansion,  tilde  expan-
     sion,  parameter, variable and arithmetic expansion and com-
     mand substitution (done in a  left-to-right  fashion),  word
     splitting, and pathname expansion.

     On systems that can  support  it,  there  is  an  additional
     expansion available: _p_r_o_c_e_s_s _s_u_b_s_t_i_t_u_t_i_o_n.

     Only brace expansion, word splitting, and pathname expansion
     can  change  the  number  of  words  of the expansion; other
     expansions expand a single word to a single word.  The  only
     exceptions   to  this  are  the  expansions  of  ``$@''  and
     ``${_n_a_m_e[@]}'' as explained above (see PARAMETERS).

  Brace Expansion
     _B_r_a_c_e _e_x_p_a_n_s_i_o_n is a mechanism by  which  arbitrary  strings
     may  be  generated.   This  mechanism is similar to _p_a_t_h_n_a_m_e
     _e_x_p_a_n_s_i_o_n, but the filenames generated need not exist.  Pat-
     terns  to  be  brace  expanded  take the form of an optional
     _p_r_e_a_m_b_l_e, followed by a series  of  comma-separated  strings
     between a pair of braces, followed by an optional _p_o_s_t_a_m_b_l_e.
     The preamble is prefixed to each string contained within the
     braces, and the postamble is then appended to each resulting
     string, expanding left to right.




GNU                 Last change: 1996 Nov 25                   19






User Commands                                             BASH(1)



     Brace  expansions  may  be  nested.   The  results  of  each
     expanded  string  are  not  sorted;  left  to right order is
     preserved.  For example, a{d,c,b}e  expands  into  `ade  ace
     abe'.

     Brace expansion is performed before  any  other  expansions,
     and any characters special to other expansions are preserved
     in the result.  It is strictly textual.  Bash does not apply
     any syntactic interpretation to the context of the expansion
     or the text between the braces.

     A correctly-formed brace  expansion  must  contain  unquoted
     opening and closing braces, and at least one unquoted comma.
     Any incorrectly formed brace expansion is left unchanged.  A
     {  or  , may be quoted with a backslash to prevent its being
     considered part of a brace expression.

     This construct is typically used as shorthand when the  com-
     mon  prefix of the strings to be generated is longer than in
     the above example:

          mkdir /usr/local/src/bash/{old,new,dist,bugs}
     or
          chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}

     Brace expansion introduces  a  slight  incompatibility  with
     historical  versions  of  sh.   sh does not treat opening or
     closing braces specially when they appear as part of a word,
     and  preserves them in the output.  Bash removes braces from
     words as a consequence of brace expansion.  For  example,  a
     word  entered  to sh as _f_i_l_e{_1,_2} appears identically in the
     output.  The same word is output as _f_i_l_e_1 _f_i_l_e_2 after expan-
     sion  by  bash.  If strict compatibility with sh is desired,
     start bash with the +B option  or  disable  brace  expansion
     with  the  +B  option  to the set command (see SHELL BUILTIN
     COMMANDS below).

  Tilde Expansion
     If a word begins with a tilde character (`~'),  all  of  the
     characters  preceding the first slash (or all characters, if
     there is no slash) are treated as a possible _l_o_g_i_n _n_a_m_e.  If
     this  _l_o_g_i_n  _n_a_m_e  is the null string, the tilde is replaced
     with the value of the parameter HOME.  If HOME is unset, the
     home  directory  of  the user executing the shell is substi-
     tuted instead.

     If a `+' follows the tilde, the value of  PWD  replaces  the
     tilde  and  `+'.   If  a `-' follows, the value of OLDPWD is
     substituted.  If the value following the tilde  is  a  valid
     _l_o_g_i_n  _n_a_m_e,  the tilde and _l_o_g_i_n _n_a_m_e are replaced with the
     home directory associated with that name.  If  the  name  is
     invalid,   or   the  tilde  expansion  fails,  the  word  is



GNU                 Last change: 1996 Nov 25                   20






User Commands                                             BASH(1)



     unchanged.

     Each variable assignment  is  checked  for  unquoted  tildes
     immediately  following a : or =.  In these cases, tilde sub-
     stitution is also performed.  Consequently, one may use file
     names  with  tildes  in  assignments  to PATH, MAILPATH, and
     CDPATH, and the shell assigns the expanded value.

  Parameter Expansion
     The `$' character introduces  parameter  expansion,  command
     substitution,  or  arithmetic expansion.  The parameter name
     or symbol to be expanded may be enclosed  in  braces,  which
     are  optional  but  serve  to  protect  the  variable  to be
     expanded from  characters  immediately  following  it  which
     could be interpreted as part of the name.

     ${_p_a_r_a_m_e_t_e_r}
          The value of _p_a_r_a_m_e_t_e_r is substituted.  The braces  are
          required  when _p_a_r_a_m_e_t_e_r is a positional parameter with
          more than one digit, or when _p_a_r_a_m_e_t_e_r is followed by a
          character which is not to be interpreted as part of its
          name.

     If the first character of _p_a_r_a_m_e_t_e_r is an exclamation point,
     a  level  of  variable indirection is introduced.  Bash uses
     the value of the variable formed from the rest of  _p_a_r_a_m_e_t_e_r
     as  the name of the variable; this variable is then expanded
     and that value used in the rest of the substitution,  rather
     than  the  value  of  _p_a_r_a_m_e_t_e_r  itself.   This  is known as
     _i_n_d_i_r_e_c_t _e_x_p_a_n_s_i_o_n.

     In each of the cases below, _w_o_r_d is subject to tilde  expan-
     sion,  parameter expansion, command substitution, and arith-
     metic expansion.  When not performing  substring  expansion,
     bash  tests  for a parameter that is unset or null; omitting
     the colon results in a test only for  a  parameter  that  is
     unset.

     ${_p_a_r_a_m_e_t_e_r:-_w_o_r_d}
          Use Default Values.  If _p_a_r_a_m_e_t_e_r is unset or null, the
          expansion of _w_o_r_d is substituted.  Otherwise, the value
          of _p_a_r_a_m_e_t_e_r is substituted.
     ${_p_a_r_a_m_e_t_e_r:=_w_o_r_d}
          Assign Default Values.  If _p_a_r_a_m_e_t_e_r is unset or  null,
          the  expansion  of  _w_o_r_d is assigned to _p_a_r_a_m_e_t_e_r.  The
          value of _p_a_r_a_m_e_t_e_r  is  then  substituted.   Positional
          parameters  and  special parameters may not be assigned
          to in this way.
     ${_p_a_r_a_m_e_t_e_r:?_w_o_r_d}
          Display Error if Null or Unset.  If _p_a_r_a_m_e_t_e_r  is  null
          or  unset,  the expansion of _w_o_r_d (or a message to that
          effect if _w_o_r_d  is  not  present)  is  written  to  the



GNU                 Last change: 1996 Nov 25                   21






User Commands                                             BASH(1)



          standard error and the shell, if it is not interactive,
          exits.  Otherwise, the value of  _p_a_r_a_m_e_t_e_r  is  substi-
          tuted.
     ${_p_a_r_a_m_e_t_e_r:+_w_o_r_d}
          Use Alternate Value.  If _p_a_r_a_m_e_t_e_r is  null  or  unset,
          nothing is substituted, otherwise the expansion of _w_o_r_d
          is substituted.
     ${_p_a_r_a_m_e_t_e_r:_o_f_f_s_e_t}
     ${_p_a_r_a_m_e_t_e_r:_o_f_f_s_e_t:_l_e_n_g_t_h}
          Substring Expansion.  Expands to up to  _l_e_n_g_t_h  charac-
          ters  of  _p_a_r_a_m_e_t_e_r,  starting at _o_f_f_s_e_t.  If _l_e_n_g_t_h is
          omitted, expands to the substring of _p_a_r_a_m_e_t_e_r,  start-
          ing  at  the character specified by _o_f_f_s_e_t.  _l_e_n_g_t_h and
          _o_f_f_s_e_t  are  arithmetic  expressions  (see   ARITHMETIC
          EVALUATION  below).   _l_e_n_g_t_h  must evaluate to a number
          greater than or equal to zero.  If _o_f_f_s_e_t evaluates  to
          a number less than zero, the value is used as an offset
          from the end of the value of _p_a_r_a_m_e_t_e_r.   If  _p_a_r_a_m_e_t_e_r
          is @, the result is _l_e_n_g_t_h positional parameters begin-
          ning at _o_f_f_s_e_t.  If _p_a_r_a_m_e_t_e_r is an array name  indexed
          by  @  or  *,  the  result is the _l_e_n_g_t_h members of the
          array beginning with  ${_p_a_r_a_m_e_t_e_r[_o_f_f_s_e_t]}.   Substring
          indexing is zero-based unless the positional parameters
          are used, in which case the indexing starts at 1.

     ${#_p_a_r_a_m_e_t_e_r}
          The length in characters of the value of  _p_a_r_a_m_e_t_e_r  is
          substituted.   If  _p_a_r_a_m_e_t_e_r is * or @, the length sub-
          stituted is the number of  positional  parameters.   If
          _p_a_r_a_m_e_t_e_r  is  an array name subscripted by * or @, the
          length substituted is the number  of  elements  in  the
          array.

     ${_p_a_r_a_m_e_t_e_r#_w_o_r_d}
     ${_p_a_r_a_m_e_t_e_r##_w_o_r_d}
          The _w_o_r_d is expanded to produce a pattern  just  as  in
          pathname  expansion.  If the pattern matches the begin-
          ning of the value of _p_a_r_a_m_e_t_e_r, then the  expansion  is
          the  value of _p_a_r_a_m_e_t_e_r with the shortest matching pat-
          tern (the ``#'' case) or the longest  matching  pattern
          (the ``##'' case) deleted.  If _p_a_r_a_m_e_t_e_r is @ or *, the
          pattern removal operation is applied to each positional
          parameter  in  turn, and the expansion is the resultant
          list.  If _p_a_r_a_m_e_t_e_r is an  array  variable  subscripted
          with  @  or *, the pattern removal operation is applied
          to each member of the array in turn, and the  expansion
          is the resultant list.

     ${_p_a_r_a_m_e_t_e_r%_w_o_r_d}
     ${_p_a_r_a_m_e_t_e_r%%_w_o_r_d}
          The _w_o_r_d is expanded to produce a pattern  just  as  in
          pathname  expansion.  If the pattern matches a trailing



GNU                 Last change: 1996 Nov 25                   22






User Commands                                             BASH(1)



          portion of the value of _p_a_r_a_m_e_t_e_r, then  the  expansion
          is  the  value  of _p_a_r_a_m_e_t_e_r with the shortest matching
          pattern (the ``%'' case) or the longest  matching  pat-
          tern  (the  ``%%'' case) deleted.  If _p_a_r_a_m_e_t_e_r is @ or
          *, the pattern removal operation  is  applied  to  each
          positional  parameter in turn, and the expansion is the
          resultant list.  If _p_a_r_a_m_e_t_e_r is an array variable sub-
          scripted  with @ or *, the pattern removal operation is
          applied to each member of the array in  turn,  and  the
          expansion is the resultant list.

     ${_p_a_r_a_m_e_t_e_r/_p_a_t_t_e_r_n/_s_t_r_i_n_g}
     ${_p_a_r_a_m_e_t_e_r//_p_a_t_t_e_r_n/_s_t_r_i_n_g}
          The _p_a_t_t_e_r_n is expanded to produce a pattern just as in
          pathname  expansion.   _P_a_r_a_m_e_t_e_r  is  expanded  and the
          longest match of _p_a_t_t_e_r_n against its value is  replaced
          with  _s_t_r_i_n_g.   In the first form, only the first match
          is replaced.  The second form  causes  all  matches  of
          _p_a_t_t_e_r_n  to be replaced with _s_t_r_i_n_g.  If _p_a_t_t_e_r_n begins
          with #, it must match at the beginning of  _s_t_r_i_n_g.   If
          _p_a_t_t_e_r_n  begins  with  %,  it  must match at the end of
          _s_t_r_i_n_g.  If _s_t_r_i_n_g is  null,  matches  of  _p_a_t_t_e_r_n  are
          deleted and the / following _p_a_t_t_e_r_n may be omitted.  If
          _p_a_r_a_m_e_t_e_r is @ or  *,  the  substitution  operation  is
          applied  to  each positional parameter in turn, and the
          expansion is the resultant list.  If  _p_a_r_a_m_e_t_e_r  is  an
          array  variable  subscripted with @ or *, the substitu-
          tion operation is applied to each member of  the  array
          in turn, and the expansion is the resultant list.

  Command Substitution
     _C_o_m_m_a_n_d _s_u_b_s_t_i_t_u_t_i_o_n allows  the  output  of  a  command  to
     replace the command name.  There are two forms:

          $(_c_o_m_m_a_n_d)
     or
          `_c_o_m_m_a_n_d`

     Bash performs the expansion by executing _c_o_m_m_a_n_d and replac-
     ing the command substitution with the standard output of the
     command, with any trailing newlines deleted.

     When the old-style backquote form of substitution  is  used,
     backslash  retains  its literal meaning except when followed
     by $, `, or \.  When using the $(_c_o_m_m_a_n_d) form, all  charac-
     ters  between  the parentheses make up the command; none are
     treated specially.

     Command substitutions may be nested.  To nest when using the
     old form, escape the inner backquotes with backslashes.





GNU                 Last change: 1996 Nov 25                   23






User Commands                                             BASH(1)



     If the  substitution  appears  within  double  quotes,  word
     splitting  and  pathname  expansion are not performed on the
     results.

  Arithmetic Expansion
     Arithmetic expansion allows the evaluation of an  arithmetic
     expression  and  the substitution of the result.  The format
     for arithmetic expansion is:

          $((_e_x_p_r_e_s_s_i_o_n))

     The _e_x_p_r_e_s_s_i_o_n is  treated  as  if  it  were  within  double
     quotes,  but  a  double  quote inside the parentheses is not
     treated specially.  All tokens  in  the  expression  undergo
     parameter expansion, string expansion, command substitution,
     and quote removal.  Arithmetic substitutions may be nested.

     The evaluation is performed according to  the  rules  listed
     below   under   ARITHMETIC  EVALUATION.   If  _e_x_p_r_e_s_s_i_o_n  is
     invalid, bash prints a message  indicating  failure  and  no
     substitution occurs.

  Process Substitution
     _P_r_o_c_e_s_s _s_u_b_s_t_i_t_u_t_i_o_n is supported on  systems  that  support
     named  pipes  (_F_I_F_O_s)  or  the /dev/fd method of naming open
     files.  It takes the form of <(_l_i_s_t) or >(_l_i_s_t).   The  pro-
     cess  _l_i_s_t  is  run  with its input or output connected to a
     _F_I_F_O or some file in /dev/fd.  The  name  of  this  file  is
     passed  as  an argument to the current command as the result
     of the expansion.  If the >(_l_i_s_t) form is used,  writing  to
     the  file  will provide input for _l_i_s_t.  If the <(_l_i_s_t) form
     is used, the file passed as an argument should  be  read  to
     obtain the output of _l_i_s_t.

     On systems that support it,  _p_r_o_c_e_s_s  _s_u_b_s_t_i_t_u_t_i_o_n  is  per-
     formed simultaneously with parameter and variable expansion,
     command substitution, and arithmetic expansion.

  Word Splitting
     The shell scans the results of parameter expansion,  command
     substitution,  and  arithmetic  expansion that did not occur
     within double quotes for _w_o_r_d _s_p_l_i_t_t_i_n_g.

     The shell treats each character of IFS as a  delimiter,  and
     splits  the  results  of  the other expansions into words on
     these characters.  If IFS is unset, or its value is  exactly
     <space><tab><newline>, the default, then any sequence of IFS
     characters serves to delimit words.   If  IFS  has  a  value
     other  than  the  default,  then sequences of the whitespace
     characters space and tab are ignored at  the  beginning  and
     end  of  the word, as long as the whitespace character is in
     the  value  of  IFS  (an  IFS  whitespace  character).   Any



GNU                 Last change: 1996 Nov 25                   24






User Commands                                             BASH(1)



     character  in IFS that is not IFS whitespace, along with any
     adjacent IFS whitespace characters,  delimits  a  field.   A
     sequence  of  IFS whitespace characters is also treated as a
     delimiter.  If the value of IFS is null, no  word  splitting
     occurs.

     Explicit null arguments ("" or '') are  retained.   Unquoted
     implicit  null  arguments,  resulting  from the expansion of
     _p_a_r_a_m_e_t_e_r_s that have no values, are removed.  If a parameter
     with no value is expanded within double quotes, a null argu-
     ment results and is retained.

     Note that if no expansion occurs, no splitting is performed.

  Pathname Expansion
     After word splitting, unless the -f  option  has  been  set,
     bash scans each word for the characters *, ?, and [.  If one
     of these characters appears, then the word is regarded as  a
     _p_a_t_t_e_r_n,  and replaced with an alphabetically sorted list of
     file names matching the pattern.  If no matching file  names
     are  found,  and  the shell option nullglob is disabled, the
     word is left unchanged.   If  the  option  is  set,  and  no
     matches  are  found, the word is removed.  When a pattern is
     used for pathname expansion,  the  character  ``.''  at  the
     start  of  a  name  or immediately following a slash must be
     matched explicitly, unless the shell option dotglob is  set.
     The  slash  character must always be matched explicitly.  In
     other cases, the ``.'' character is not  treated  specially.
     See  the description of shopt below under SHELL BUILTIN COM-
     MANDS for a description of the nullglob  and  dotglob  shell
     options.

     The GLOBIGNORE shell variable may be used  to  restrict  the
     set of file names matching a _p_a_t_t_e_r_n.  If GLOBIGNORE is set,
     each matching file name that also matches one  of  the  pat-
     terns  in  GLOBIGNORE  is  removed from the list of matches.
     The file names ``.'' and ``..''  are  always  ignored,  even
     when GLOBIGNORE is set.  However, setting GLOBIGNORE has the
     effect of enabling the dotglob shell option,  so  all  other
     file  names  beginning  with a ``.'' will match.  To get the
     old behavior of ignoring file names beginning with a  ``.'',
     make  ``.*'' one of the patterns in GLOBIGNORE.  The dotglob
     option is disabled when GLOBIGNORE is unset.

     The special pattern characters have the following meanings:

     *    Matches any string, including the null string.
     ?    Matches any single character.
     [...]
          Matches any one of the enclosed characters.  A pair  of
          characters  separated  by a minus sign denotes a _r_a_n_g_e;
          any character lexically between those  two  characters,



GNU                 Last change: 1996 Nov 25                   25






User Commands                                             BASH(1)



          inclusive,  is matched.  If the first character follow-
          ing the [ is a ! or a ^ then any character not enclosed
          is  matched.  A - may be matched by including it as the
          first or last character in the set.  A ] may be matched
          by including it as the first character in the set.

  Quote Removal
     After the preceding expansions, all unquoted occurrences  of
     the  characters  \, `, and " that did not result from one of
     the above expansions are removed.

REDIRECTION
     Before a command is executed, its input and  output  may  be
     _r_e_d_i_r_e_c_t_e_d  using  a  special  notation  interpreted  by the
     shell.  Redirection may also be used to open and close files
     for  the current shell execution environment.  The following
     redirection operators may precede or appear anywhere  within
     a  _s_i_m_p_l_e _c_o_m_m_a_n_d or may follow a _c_o_m_m_a_n_d.  Redirections are
     processed in the order they appear, from left to right.

     In the following descriptions, if the file descriptor number
     is  omitted,  and  the  first  character  of the redirection
     operator is <, the redirection refers to the standard  input
     (file descriptor 0).  If the first character of the redirec-
     tion operator is >, the redirection refers to  the  standard
     output (file descriptor 1).

     The word that follows the redirection operator in  the  fol-
     lowing  descriptions  is subjected to brace expansion, tilde
     expansion, parameter expansion, command substitution, arith-
     metic  expansion, quote removal, and pathname expansion.  If
     it expands to more than one word, bash reports an error.

     Note that the order of  redirections  is  significant.   For
     example, the command

          ls > dirlist 2>&1

     directs both standard output and standard error to the  file
     _d_i_r_l_i_s_t, while the command

          ls 2>&1 > dirlist

     directs only the standard output to  file  _d_i_r_l_i_s_t,  because
     the  standard error was duplicated as standard output before
     the standard output was redirected to _d_i_r_l_i_s_t.

  Redirecting Input
     Redirection of input causes the file whose name results from
     the  expansion  of  _w_o_r_d  to  be  opened for reading on file
     descriptor _n, or the standard input (file descriptor 0) if _n
     is not specified.



GNU                 Last change: 1996 Nov 25                   26






User Commands                                             BASH(1)



     The general format for redirecting input is:

          [_n]<_w_o_r_d

  Redirecting Output
     Redirection of output causes the  file  whose  name  results
     from  the expansion of _w_o_r_d to be opened for writing on file
     descriptor _n, or the standard output (file descriptor 1)  if
     _n  is  not  specified.   If  the  file  does not exist it is
     created; if it does exist it is truncated to zero size.

     The general format for redirecting output is:

          [_n]>_w_o_r_d

     If the redirection operator is >, and the -C option  to  the
     set  builtin  has been enabled, the redirection will fail if
     the filename whose name results from the expansion  of  _w_o_r_d
     exists.   If  the redirection operator is >|, then the value
     of the -C option to the set builtin command is  not  tested,
     and  the  redirection is attempted even if the file named by
     _w_o_r_d exists.

  Appending Redirected Output
     Redirection of output in this fashion causes the file  whose
     name  results  from  the  expansion of _w_o_r_d to be opened for
     appending on file descriptor _n, or the standard output (file
     descriptor  1)  if _n is not specified.  If the file does not
     exist it is created.

     The general format for appending output is:

          [_n]>>_w_o_r_d

  Redirecting Standard Output and Standard Error
     Bash allows both the standard output (file descriptor 1) and
     the   standard  error  output  (file  descriptor  2)  to  be
     redirected to the file whose name is the expansion  of  _w_o_r_d
     with this construct.

     There are two formats for redirecting  standard  output  and
     standard error:

          &>_w_o_r_d
     and
          >&_w_o_r_d

     Of the two forms, the first is preferred.  This is  semanti-
     cally equivalent to

          >_w_o_r_d 2>&1




GNU                 Last change: 1996 Nov 25                   27






User Commands                                             BASH(1)



  Here Documents
     This type of redirection instructs the shell to  read  input
     from  the  current  source until a line containing only _w_o_r_d
     (with no trailing blanks) is seen.  All of the lines read up
     to that point are then used as the standard input for a com-
     mand.

     The format of here-documents is as follows:

          <<[-]_w_o_r_d
                  _h_e_r_e-_d_o_c_u_m_e_n_t
          _d_e_l_i_m_i_t_e_r

     No  parameter  expansion,  command  substitution,   pathname
     expansion, or arithmetic expansion is performed on _w_o_r_d.  If
     any characters in _w_o_r_d are  quoted,  the  _d_e_l_i_m_i_t_e_r  is  the
     result  of quote removal on _w_o_r_d, and the lines in the here-
     document are not expanded.   Otherwise,  all  lines  of  the
     here-document  are subjected to parameter expansion, command
     substitution, and arithmetic expansion.  In the latter case,
     the  pair \<newline> is ignored, and \ must be used to quote
     the characters \, $, and `.

     If the redirection operator is <<-,  then  all  leading  tab
     characters  are  stripped from input lines and the line con-
     taining _d_e_l_i_m_i_t_e_r.  This allows here-documents within  shell
     scripts to be indented in a natural fashion.

  Duplicating File Descriptors
     The redirection operator

          [_n]<&_w_o_r_d

     is used  to  duplicate  input  file  descriptors.   If  _w_o_r_d
     expands  to  one or more digits, the file descriptor denoted
     by _n is made to be a copy of that file descriptor.  If  _w_o_r_d
     evaluates  to  -,  file descriptor _n is closed.  If _n is not
     specified, the standard input (file descriptor 0) is used.

     The operator

          [_n]>&_w_o_r_d

     is used similarly to duplicate output file descriptors.   If
     _n  is not specified, the standard output (file descriptor 1)
     is used.  As a special case, if _n is omitted, and _w_o_r_d  does
     not  expand  to  one or more digits, the standard output and
     standard error are redirected as described previously.

  Opening File Descriptors for Reading and Writing
     The redirection operator




GNU                 Last change: 1996 Nov 25                   28






User Commands                                             BASH(1)



          [_n]<>_w_o_r_d

     causes the file whose name is the expansion of  _w_o_r_d  to  be
     opened for both reading and writing on file descriptor _n, or
     on file descriptor 0 if _n is not  specified.   If  the  file
     does not exist, it is created.

ALIASES
     The shell maintains a list of _a_l_i_a_s_e_s that may  be  set  and
     unset with the alias and unalias builtin commands (see SHELL
     BUILTIN COMMANDS below).  The first word of each command, if
     unquoted, is checked to see if it has an alias.  If so, that
     word is replaced by the text of the alias.  The  alias  name
     and  the replacement text may contain any valid shell input,
     including the _m_e_t_a_c_h_a_r_a_c_t_e_r_s listed above, with  the  excep-
     tion  that the alias name may not contain =.  The first word
     of the replacement text is tested for aliases,  but  a  word
     that is identical to an alias being expanded is not expanded
     a second time.  This means that one may alias ls to  ls  -F,
     for  instance,  and  bash does not try to recursively expand
     the replacement text.  If the last character  of  the  alias
     value  is  a _b_l_a_n_k, then the next command word following the
     alias is also checked for alias expansion.

     Aliases are created and listed with the alias  command,  and
     removed with the unalias command.

     There is no mechanism for using arguments in the replacement
     text.   If  arguments are needed, a shell function should be
     used.

     Aliases are not expanded when the shell is not  interactive,
     unless  the  expand_aliases  shell option is set using shopt
     (see the description of shopt under SHELL  BUILTIN  COMMANDS
     below).

     The rules concerning the definition and use of  aliases  are
     somewhat confusing.  Bash always reads at least one complete
     line of input before executing any of the commands  on  that
     line.  Aliases are expanded when a command is read, not when
     it is executed.  Therefore, an alias definition appearing on
     the  same line as another command does not take effect until
     the next line of input is read.  The commands following  the
     alias  definition  on  that line are not affected by the new
     alias.  This behavior is also an issue  when  functions  are
     executed.  Aliases are expanded when the function definition
     is read, not when the function is executed, because a  func-
     tion  definition  is itself a compound command.  As a conse-
     quence, aliases defined in  a  function  are  not  available
     until  after  that function is executed.  To be safe, always
     put alias definitions on a separate line,  and  do  not  use
     alias in compound commands.



GNU                 Last change: 1996 Nov 25                   29






User Commands                                             BASH(1)



     Note that for almost every purpose, aliases  are  superseded
     by shell functions.

FUNCTIONS
     A shell function, defined as  described  above  under  SHELL
     GRAMMAR,  stores  a  series of commands for later execution.
     Functions are executed in the context of the current  shell;
     no  new  process is created to interpret them (contrast this
     with the execution of a shell script).  When a  function  is
     executed,  the  arguments  to  the function become the posi-
     tional parameters during its execution.  The special parame-
     ter  # is updated to reflect the change.  Positional parame-
     ter 0 is unchanged.  All other aspects of the  shell  execu-
     tion  environment  are  identical between a function and its
     caller with the exception  that  the  DEBUG  trap  (see  the
     description of the trap builtin under SHELL BUILTIN COMMANDS
     below) is not inherited.

     Variables local to the function may  be  declared  with  the
     local  builtin  command.   Ordinarily,  variables  and their
     values are shared between the function and its caller.

     If the builtin command return is executed in a function, the
     function  completes and execution resumes with the next com-
     mand after the function call.  When  a  function  completes,
     the  values  of  the  positional  parameters and the special
     parameter # are restored to the values  they  had  prior  to
     function execution.

     Function names and definitions may be  listed  with  the  -f
     option  to  the declare or typeset builtin commands.  The -F
     option to declare or typeset will list  the  function  names
     only.  Functions may be exported so that subshells automati-
     cally have them defined with the -f  option  to  the  export
     builtin.

     Functions may be recursive.  No  limit  is  imposed  on  the
     number of recursive calls.

COMMAND EXECUTION
     After a command has been split into words, if it results  in
     a simple command and an optional list of arguments, the fol-
     lowing actions are taken.

     If the command name contains no slashes, the shell  attempts
     to  locate  it.   If  there  exists a shell function by that
     name, that function is invoked as described above  in  FUNC-
     TIONS.   If  the  name  does not match a function, the shell
     searches for it in the list of shell builtins.  If  a  match
     is found, that builtin is invoked.





GNU                 Last change: 1996 Nov 25                   30






User Commands                                             BASH(1)



     If the name is neither a shell function nor a  builtin,  and
     contains  no slashes, bash searches each element of the PATH
     for a directory containing an executable file by that  name.
     Bash  uses  a  hash table to remember the full file names of
     executable files (see  hash  under  SHELL  BUILTIN  COMMANDS
     below).   A  full  search of the directories in PATH is per-
     formed only if the command is not found in the  hash  table.
     If  the  search  is  unsuccessful, the shell prints an error
     message and returns a non-zero exit status.

     If the search is successful, or if the command name contains
     one  or  more slashes, the shell executes the named program.
     Argument 0 is set to the name given, and the remaining argu-
     ments to the command are set to the arguments given, if any.

     If this execution fails because the file is not  in  execut-
     able  format, and the file is not a directory, it is assumed
     to be a _s_h_e_l_l _s_c_r_i_p_t, a file containing shell  commands.   A
     subshell is spawned to execute it.  This subshell reinitial-
     izes itself, so that the effect is as if  a  new  shell  had
     been  invoked  to handle the script, with the exception that
     the locations of commands remembered by the parent (see hash
     below  under  SHELL  BUILTIN  COMMANDS)  are retained by the
     child.

     If the program is a file beginning with #!, the remainder of
     the  first  line  specifies  an interpreter for the program.
     The shell executes the specified  interpreter  on  operating
     systems  that  do  not  handle  this executable format them-
     selves.  The arguments to the interpreter consist of a  sin-
     gle  optional argument following the interpreter name on the
     first line of the program, followed by the name of the  pro-
     gram, followed by the command arguments, if any.

ENVIRONMENT
     When a program is invoked it is given an  array  of  strings
     called the _e_n_v_i_r_o_n_m_e_n_t.  This is a list of _n_a_m_e-_v_a_l_u_e pairs,
     of the form _n_a_m_e=_v_a_l_u_e.

     The shell  allows  you  to  manipulate  the  environment  in
     several  ways.   On  invocation,  the  shell  scans  its own
     environment and creates a parameter  for  each  name  found,
     automatically  marking  it  for  _e_x_p_o_r_t  to child processes.
     Executed commands inherit the environment.  The  export  and
     declare  -x  commands  allow  parameters and functions to be
     added to and deleted from the environment.  If the value  of
     a  parameter  in  the environment is modified, the new value
     becomes part of the environment,  replacing  the  old.   The
     environment  inherited  by  any executed command consists of
     the shell's initial environment, whose values may  be  modi-
     fied  in the shell, less any pairs removed by the unset com-
     mand, plus any additions  via  the  export  and  declare  -x



GNU                 Last change: 1996 Nov 25                   31






User Commands                                             BASH(1)



     commands.

     The environment for any _s_i_m_p_l_e _c_o_m_m_a_n_d or  function  may  be
     augmented temporarily by prefixing it with parameter assign-
     ments, as described above in PARAMETERS.   These  assignment
     statements affect only the environment seen by that command.

     If the -k flag is set (see the set builtin  command  below),
     then _a_l_l parameter assignments are placed in the environment
     for a command, not just those that precede the command name.

     When bash invokes an external command, the variable _ is set
     to the full file name of the command and passed to that com-
     mand in its environment.

EXIT STATUS
     For the purposes of the shell, a command which exits with  a
     zero  exit  status  has  succeeded.   An exit status of zero
     indicates  success.   A  non-zero  exit   status   indicates
     failure.   When a command terminates on a fatal signal, bash
     uses the value of 128+signal as the exit status.

     If a command is not found, the child process created to exe-
     cute  it returns a status of 127.  If a command is found but
     is not executable, the return status is 126.

     Shell builtin commands return a status of 0 (_t_r_u_e)  if  suc-
     cessful,  and non-zero (_f_a_l_s_e) if an error occurs while they
     execute. All builtins return an exit status of 2 to indicate
     incorrect usage.

     Bash itself returns the exit status of the last command exe-
     cuted,  unless a syntax error occurs, in which case it exits
     with a non-zero value.  See also the  exit  builtin  command
     below.

SIGNALS
     When bash is interactive, it ignores SIGTERM (so that kill 0
     does  not  kill  an interactive shell), and SIGINT is caught
     and handled (so that the wait builtin is interruptible).  In
     all  cases,  bash  ignores  SIGQUIT.   If  job control is in
     effect, bash ignores SIGTTIN, SIGTTOU, and SIGTSTP.

     Synchronous jobs started by bash have  signals  set  to  the
     values  inherited  by  the  shell from its parent.  When job
     control is not in effect, background jobs (jobs started with
     &)  ignore  SIGINT and SIGQUIT.  Commands run as a result of
     command substitution ignore the keyboard-generated job  con-
     trol signals SIGTTIN, SIGTTOU, and SIGTSTP.

     The shell exits by default upon receipt of a SIGHUP.  Before
     exiting,  it  resends  the  SIGHUP  to  all jobs, running or



GNU                 Last change: 1996 Nov 25                   32






User Commands                                             BASH(1)



     stopped.  To prevent the shell from sending the signal to  a
     particular  job,  remove  it  from  the  jobs table with the
     disown builtin (see SHELL BUILTIN  COMMANDS  below)  or  use
     disown -h to mark it to not receive SIGHUP.

JOB CONTROL
     _J_o_b _c_o_n_t_r_o_l  refers  to  the  ability  to  selectively  stop
     (_s_u_s_p_e_n_d)  the  execution of processes and continue (_r_e_s_u_m_e)
     their execution at a later point.  A user typically  employs
     this  facility via an interactive interface supplied jointly
     by the system's terminal driver and bash.

     The shell associates a _j_o_b with each pipeline.  It  keeps  a
     table  of currently executing jobs, which may be listed with
     the jobs command.  When bash starts a job asynchronously (in
     the _b_a_c_k_g_r_o_u_n_d), it prints a line that looks like:

          [1] 25647

     indicating that this job is job number 1 and that  the  pro-
     cess  ID of the last process in the pipeline associated with
     this job is 25647.  All of the processes in a  single  pipe-
     line  are  members  of  the  same  job.   Bash  uses the _j_o_b
     abstraction as the basis for job control.

     To facilitate the implementation of the  user  interface  to
     job  control,  the  system maintains the notion of a _c_u_r_r_e_n_t
     _t_e_r_m_i_n_a_l _p_r_o_c_e_s_s _g_r_o_u_p _I_D.  Members of  this  process  group
     (processes  whose  process  group ID is equal to the current
     terminal process group ID) receive  keyboard-generated  sig-
     nals  such as SIGINT.  These processes are said to be in the
     _f_o_r_e_g_r_o_u_n_d.  _B_a_c_k_g_r_o_u_n_d processes are  those  whose  process
     group  ID  differs  from  the terminal's; such processes are
     immune  to  keyboard-generated  signals.   Only   foreground
     processes are allowed to read from or write to the terminal.
     Background processes which attempt to read from  (write  to)
     the terminal are sent a SIGTTIN (SIGTTOU) signal by the ter-
     minal driver, which, unless caught, suspends the process.

     If the operating system on which bash  is  running  supports
     job  control, bash allows you to use it.  Typing the _s_u_s_p_e_n_d
     character (typically ^Z, Control-Z) while a process is  run-
     ning  causes  that  process to be stopped and returns you to
     bash.  Typing the _d_e_l_a_y_e_d _s_u_s_p_e_n_d character  (typically  ^Y,
     Control-Y) causes the process to be stopped when it attempts
     to read input from the terminal, and control to be  returned
     to  bash.   You  may  then manipulate the state of this job,
     using the bg command to continue it in the  background,  the
     fg  command  to  continue  it in the foreground, or the kill
     command to kill it.  A ^Z takes effect immediately, and  has
     the  additional  side  effect  of causing pending output and
     typeahead to be discarded.



GNU                 Last change: 1996 Nov 25                   33






User Commands                                             BASH(1)



     There are a number of ways to refer to a job in  the  shell.
     The  character % introduces a job name.  Job number _n may be
     referred to as %n.  A job may also be referred  to  using  a
     prefix  of  the  name used to start it, or using a substring
     that appears in its command line.  For example,  %ce  refers
     to a stopped ce job.  If a prefix matches more than one job,
     bash reports an error.   Using  %?ce,  on  the  other  hand,
     refers  to  any  job containing the string ce in its command
     line.  If the substring matches  more  than  one  job,  bash
     reports  an  error.   The  symbols  %%  and  %+ refer to the
     shell's notion of the _c_u_r_r_e_n_t _j_o_b, which  is  the  last  job
     stopped  while  it  was in the foreground.  The _p_r_e_v_i_o_u_s _j_o_b
     may be referenced using %-.  In output  pertaining  to  jobs
     (e.g.,  the  output of the jobs command), the current job is
     always flagged with a +, and the previous job with a -.

     Simply naming a job can be used to bring it into  the  fore-
     ground:   %1 is a synonym for ``fg %1'', bringing job 1 from
     the background into the  foreground.   Similarly,  ``%1  &''
     resumes job 1 in the background, equivalent to ``bg %1''.

     The shell learns immediately whenever a job  changes  state.
     Normally,  bash  waits  until  it is about to print a prompt
     before reporting changes in a job's  status  so  as  to  not
     interrupt  any  other  output.   If the -b option to the set
     builtin command is set, bash reports  such  changes  immedi-
     ately.

     If an attempt to exit bash is made while jobs  are  stopped,
     the  shell  prints  a warning message.  The jobs command may
     then be used to inspect their status.  If a  second  attempt
     to  exit  is  made without an intervening command, the shell
     does not print another warning, and  the  stopped  jobs  are
     terminated.

PROMPTING
     When executing  interactively,  bash  displays  the  primary
     prompt  PS1  when  it  is  ready  to read a command, and the
     secondary prompt PS2 when it needs more input to complete  a
     command.   Bash allows these prompt strings to be customized
     by inserting a number of backslash-escaped  special  charac-
     ters that are decoded as follows:
          \a   an ASCII bell character (07)
          \d   the date in "Weekday  Month  Date"  format  (e.g.,
               "Tue May 26")
          \e   an ASCII escape character (033)
          \h   the hostname up to the first `.'
          \H   the hostname
          \n   newline
          \s   the name of the shell, the  basename  of  $0  (the
               portion following the final slash)
          \t   the current time in 24-hour HH:MM:SS format



GNU                 Last change: 1996 Nov 25                   34






User Commands                                             BASH(1)



          \T   the current time in 12-hour HH:MM:SS format
          \@   the current time in 12-hour am/pm format
          \u   the username of the current user
          \v   the version of bash (e.g., 2.00)
          \V   the release of bash, version +  patchlevel  (e.g.,
               2.00.0)
          \w   the current working directory
          \W   the basename of the current working directory
          \!   the history number of this command
          \#   the command number of this command
          \$   if the effective UID is 0, a #, otherwise a $
          \_n_n_n the character corresponding to  the  octal  number
               _n_n_n
          \\   a backslash
          \[   begin a sequence of non-printing characters, which
               could be used to embed a terminal control sequence
               into the prompt
          \]   end a sequence of non-printing characters

     The command number and the history number are  usually  dif-
     ferent:   the history number of a command is its position in
     the history list, which may include commands  restored  from
     the  history  file  (see  HISTORY  below), while the command
     number is the position in the sequence of commands  executed
     during  the  current  shell  session.   After  the string is
     decoded, it is expanded  via  parameter  expansion,  command
     substitution,  arithmetic  expansion,  string expansion, and
     quote removal, subject to the value of the promptvars  shell
     option (see the description of the shopt command under SHELL
     BUILTIN COMMANDS below).

READLINE
     This is the library that handles reading input when using an
     interactive  shell, unless the -noediting option is given at
     shell invocation.  By default, the line editing commands are
     similar  to  those of emacs.  A vi-style line editing inter-
     face is also available.  To turn off line editing after  the
     shell  is  running, use the +o emacs or +o vi options to the
     set builtin (see SHELL BUILTIN COMMANDS below).

  Readline Notation
     In this section, the emacs-style notation is used to  denote
     keystrokes.   Control  keys  are denoted by C-_k_e_y, e.g., C-n
     means Control-N.  Similarly, _m_e_t_a keys are denoted by M-_k_e_y,
     so  M-x means Meta-X.  (On keyboards without a _m_e_t_a key, M-_x
     means ESC _x, i.e., press the Escape  key  then  the  _x  key.
     This makes ESC the _m_e_t_a _p_r_e_f_i_x.  The combination M-C-_x means
     ESC-Control-_x, or press the Escape key then hold the Control
     key while pressing the _x key.)

     Readline commands may be given numeric _a_r_g_u_m_e_n_t_s, which nor-
     mally  act as a repeat count.  Sometimes, however, it is the



GNU                 Last change: 1996 Nov 25                   35






User Commands                                             BASH(1)



     sign of the argument that is significant.  Passing  a  nega-
     tive  argument  to a command that acts in the forward direc-
     tion (e.g., kill-line) causes that command to act in a back-
     ward direction. Commands whose behavior with arguments devi-
     ates from this are noted below.

     When a command  is  described  as  _k_i_l_l_i_n_g  text,  the  text
     deleted  is  saved  for possible future retrieval (_y_a_n_k_i_n_g).
     The killed text is saved in a _k_i_l_l _r_i_n_g.  Consecutive  kills
     cause the text to be accumulated into one unit, which can be
     yanked all at once. Commands which do not kill text separate
     the chunks of text on the kill ring.

  Readline Initialization
     Readline is customized by putting commands in an initializa-
     tion  file  (the  _i_n_p_u_t_r_c  file).   The name of this file is
     taken from the value of the INPUTRC variable.  If that vari-
     able  is  unset,  the default is ~/._i_n_p_u_t_r_c.  When a program
     which uses the readline library starts up,  the  initializa-
     tion  file  is  read, and the key bindings and variables are
     set.  There are only a few basic constructs allowed  in  the
     readline  initialization  file.   Blank  lines  are ignored.
     Lines beginning with a # are comments.  Lines beginning with
     a $ indicate conditional constructs.  Other lines denote key
     bindings and variable settings.

     The default key-bindings may  be  changed  with  an  _i_n_p_u_t_r_c
     file.   Other  programs  that use this library may add their
     own commands and bindings.

     For example, placing

          M-Control-u: universal-argument
     or
          C-Meta-u: universal-argument
     into the _i_n_p_u_t_r_c would make M-C-u execute the readline  com-
     mand _u_n_i_v_e_r_s_a_l-_a_r_g_u_m_e_n_t.

     The  following  symbolic  character  names  are  recognized:
     _R_U_B_O_U_T, _D_E_L, _E_S_C, _L_F_D, _N_E_W_L_I_N_E, _R_E_T, _R_E_T_U_R_N, _S_P_C, _S_P_A_C_E, and
     _T_A_B.  In addition to command names, readline allows keys  to
     be  bound  to  a  string  that  is  inserted when the key is
     pressed (a _m_a_c_r_o).

  Readline Key Bindings
     The syntax for controlling key bindings  in  the  ~/._i_n_p_u_t_r_c
     file  is  simple.   All  that is required is the name of the
     command or the text of a macro and a key sequence  to  which
     it  should be bound. The name may be specified in one of two
     ways:  as a symbolic key name, possibly with _M_e_t_a-  or  _C_o_n_-
     _t_r_o_l-  prefixes,  or as a key sequence.  When using the form
     keyname:_f_u_n_c_t_i_o_n-_n_a_m_e or _m_a_c_r_o, _k_e_y_n_a_m_e is the name of a key



GNU                 Last change: 1996 Nov 25                   36






User Commands                                             BASH(1)



     spelled out in English.  For example:

          Control-u: universal-argument
          Meta-Rubout: backward-kill-word
          Control-o: "> output"

     In  the  above  example,  _C-_u  is  bound  to  the   function
     universal-argument,   _M-_D_E_L   is   bound   to  the  function
     backward-kill-word, and  _C-_o  is  bound  to  run  the  macro
     expressed  on  the  right  hand side (that is, to insert the
     text > _o_u_t_p_u_t into the line).

     In the second form, "keyseq":_f_u_n_c_t_i_o_n-_n_a_m_e or _m_a_c_r_o,  keyseq
     differs  from  keyname  above  in  that  strings denoting an
     entire key sequence may be specified by placing the sequence
     within  double quotes.  Some GNU Emacs style key escapes can
     be used, as in the following example.

          "\C-u": universal-argument
          "\C-x\C-r": re-read-init-file
          "\e[11~": "Function Key 1"

     In  this  example,  _C-_u  is  again  bound  to  the  function
     universal-argument.   _C-_x  _C-_r  is  bound  to  the  function
     re-read-init-file, and _E_S_C [ _1 _1 ~ is bound  to  insert  the
     text Function Key 1.  The full set of escape sequences is

          \C-  control prefix

          \M-  meta prefix

          \e   an escape character

          \\   backslash

          " \" literal "

          \'   literal '

     When entering the text of a macro, single or  double  quotes
     should  be  used  to  indicate a macro definition.  Unquoted
     text is assumed to be a function name.  Backslash will quote
     any character in the macro text, including " and '.

     Bash  allows  the  current  readline  key  bindings  to   be
     displayed  or  modified  with the bind builtin command.  The
     editing mode may be switched during interactive use by using
     the  -o option to the set builtin command (see SHELL BUILTIN
     COMMANDS below).

  Readline Variables




GNU                 Last change: 1996 Nov 25                   37






User Commands                                             BASH(1)



     Readline has variables that can be used to further customize
     its  behavior.   A  variable  may be set in the _i_n_p_u_t_r_c file
     with a statement of the form

          set _v_a_r_i_a_b_l_e-_n_a_m_e _v_a_l_u_e

     Except where noted, readline variables can take  the  values
     On or Off.  The variables and their default values are:

     bell-style (audible)
          Controls what happens when readline wants to  ring  the
          terminal  bell.   If  set to none, readline never rings
          the bell.  If set to visible, readline uses  a  visible
          bell  if one is available.  If set to audible, readline
          attempts to ring the terminal's bell.
     comment-begin (``#'')
          The  string  that  is  inserted   when   the   readline
          insert-comment  command  is  executed.  This command is
          bound to M-# in emacs mode and to # in vi command mode.
     completion-query-items (100)
          This determines when the user is queried about  viewing
          the  number  of  possible  completions generated by the
          possible-completions command.  It may  be  set  to  any
          integer  value  greater  than or equal to zero.  If the
          number of possible completions is greater than or equal
          to  the  value  of  this  variable,  the  user is asked
          whether or not he wishes to view them;  otherwise  they
          are simply listed on the terminal.
     convert-meta (On)
          If set to On, readline will convert characters with the
          eighth  bit  set  to an ASCII key sequence by stripping
          the eighth bit and prepending an escape  character  (in
          effect, using escape as the _m_e_t_a _p_r_e_f_i_x).
     disable-completion (Off)
          If set to On, readline will  inhibit  word  completion.
          Completion characters will be inserted into the line as
          if they had been mapped to self-insert.
     editing-mode (emacs)
          Controls whether readline begins  with  a  set  of  key
          bindings  similar  to _e_m_a_c_s or _v_i.  editing-mode can be
          set to either emacs or vi.
     enable-keypad (Off)
          When set to On, readline will try to enable the  appli-
          cation  keypad  when  it  is called.  Some systems need
          this to enable the arrow keys.
     expand-tilde (Off)
          If set to on, tilde expansion is performed  when  read-
          line attempts word completion.
     horizontal-scroll-mode (Off)
          When set to On, makes readline use a  single  line  for
          display,  scrolling  the input horizontally on a single
          screen line when it  becomes  longer  than  the  screen



GNU                 Last change: 1996 Nov 25                   38






User Commands                                             BASH(1)



          width rather than wrapping to a new line.
     input-meta (Off)
          If set to On,  readline  will  enable  eight-bit  input
          (that is, it will not strip the high bit from the char-
          acters it  reads),  regardless  of  what  the  terminal
          claims it can support.  The name meta-flag is a synonym
          for this variable.
     keymap (emacs)
          Set the current readline keymap.  The set of legal key-
          map   names   is   _e_m_a_c_s,  _e_m_a_c_s-_s_t_a_n_d_a_r_d,  _e_m_a_c_s-_m_e_t_a,
          _e_m_a_c_s-_c_t_l_x,  _v_i,  _v_i-_c_o_m_m_a_n_d,  and  _v_i-_i_n_s_e_r_t.   _v_i  is
          equivalent   to  _v_i-_c_o_m_m_a_n_d;  _e_m_a_c_s  is  equivalent  to
          _e_m_a_c_s-_s_t_a_n_d_a_r_d.  The default value is _e_m_a_c_s; the  value
          of editing-mode also affects the default keymap.
     mark-directories (On)
          If set to On, completed directory names  have  a  slash
          appended.
     mark-modified-lines (Off)
          If set to On, history lines that have been modified are
          displayed with a preceding asterisk (*).
     output-meta (Off)
          If set to On, readline will display characters with the
          eighth  bit set directly rather than as a meta-prefixed
          escape sequence.
     show-all-if-ambiguous (Off)
          This alters the  default  behavior  of  the  completion
          functions.   If  set  to on, words which have more than
          one possible completion cause the matches to be  listed
          immediately instead of ringing the bell.
     visible-stats (Off)
          If set to On, a character denoting  a  file's  type  as
          reported  by  _s_t_a_t(2)  is appended to the filename when
          listing possible completions.

  Readline Conditional Constructs
     Readline implements a facility similar in spirit to the con-
     ditional  compilation  features  of the C preprocessor which
     allows key bindings and variable settings to be performed as
     the  result  of  tests.   There  are three parser directives
     used.

     $if  The $if construct allows bindings to be made  based  on
          the  editing  mode,  the  terminal  being  used, or the
          application using  readline.   The  text  of  the  test
          extends  to  the  end  of  the  line; no characters are
          required to isolate it.

          mode The mode= form of the $if  directive  is  used  to
               test  whether  readline  is  in  emacs or vi mode.
               This may be used in conjunction with the set  key-
               map  command, for instance, to set bindings in the
               _e_m_a_c_s-_s_t_a_n_d_a_r_d  and  _e_m_a_c_s-_c_t_l_x  keymaps  only  if



GNU                 Last change: 1996 Nov 25                   39






User Commands                                             BASH(1)



               readline is starting out in emacs mode.

          term The term= form may be used  to  include  terminal-
               specific  key  bindings,  perhaps  to bind the key
               sequences output by the terminal's function  keys.
               The  word  on  the  right  side of the = is tested
               against the full name of the terminal and the por-
               tion  of  the  terminal  name  before the first -.
               This allows _s_u_n to match both _s_u_n and _s_u_n-_c_m_d, for
               instance.

          application
               The  application  construct  is  used  to  include
               application-specific settings.  Each program using
               the readline library sets  the  _a_p_p_l_i_c_a_t_i_o_n  _n_a_m_e,
               and an initialization file can test for a particu-
               lar  value.   This  could  be  used  to  bind  key
               sequences  to functions useful for a specific pro-
               gram.  For instance, the following command adds  a
               key  sequence  that quotes the current or previous
               word in Bash:
               $if Bash
               # Quote the current or previous word
               "\C-xq": "\eb\"\ef\""
               $endif

     $endif
          This command, as you saw in the previous example,  ter-
          minates an $if command.

     $else
          Commands in this branch of the $if directive  are  exe-
          cuted if the test fails.

  Searching
     Readline provides commands for searching through the command
     history (see HISTORY below) for lines containing a specified
     string.  There are two search modes:  _i_n_c_r_e_m_e_n_t_a_l  and  _n_o_n-
     _i_n_c_r_e_m_e_n_t_a_l.

     Incremental searches begin before the user has finished typ-
     ing  the  search  string.   As  each character of the search
     string is typed, readline displays the next entry  from  the
     history  matching  the  string typed so far.  An incremental
     search requires only as many characters as  needed  to  find
     the  desired history entry.  The Escape character is used to
     terminate an incremental search.  Control-J will  also  ter-
     minate  the  search.   Control-G  will  abort an incremental
     search and restore the original line.  When  the  search  is
     terminated,  the  history entry containing the search string
     becomes the current line.  To find other matching entries in
     the   history   list,   type   Control-S   or  Control-R  as



GNU                 Last change: 1996 Nov 25                   40






User Commands                                             BASH(1)



     appropriate.  This will search backward or  forward  in  the
     history  for the next entry matching the search string typed
     so far.  Any other key sequence bound to a readline  command
     will  terminate  the  search  and execute that command.  For
     instance, a _n_e_w_l_i_n_e will terminate the search and accept the
     line, thereby executing the command from the history list.

     Non-incremental  searches  read  the  entire  search  string
     before  starting  to search for matching history lines.  The
     search string may be typed by the user or part of  the  con-
     tents of the current line.

  Readline Command Names
     The following is a list of the names of the commands and the
     default  key  sequences  to  which  they are bound.  Command
     names without an accompanying key sequence  are  unbound  by
     default.

  Commands for Moving
     beginning-of-line (C-a)
          Move to the start of the current line.
     end-of-line (C-e)
          Move to the end of the line.
     forward-char (C-f)
          Move forward a character.
     backward-char (C-b)
          Move back a character.
     forward-word (M-f)
          Move forward to the end of the next  word.   Words  are
          composed   of   alphanumeric  characters  (letters  and
          digits).
     backward-word (M-b)
          Move back to the start of this, or the previous,  word.
          Words  are composed of alphanumeric characters (letters
          and digits).
     clear-screen (C-l)
          Clear the screen leaving the current line at the top of
          the screen.  With an argument, refresh the current line
          without clearing the screen.
     redraw-current-line
          Refresh the current line.

  Commands for Manipulating the History
     accept-line (Newline, Return)
          Accept the line regardless of where the cursor is.   If
          this  line  is  non-empty,  add  it to the history list
          according to the state of the HISTCONTROL variable.  If
          the  line  is a modified history line, then restore the
          history line to its original state.
     previous-history (C-p)
          Fetch the previous command from the history list,  mov-
          ing back in the list.



GNU                 Last change: 1996 Nov 25                   41






User Commands                                             BASH(1)



     next-history (C-n)
          Fetch the next command from the  history  list,  moving
          forward in the list.
     beginning-of-history (M-<)
          Move to the first line in the history.
     end-of-history (M->)
          Move to the end of the input history,  i.e.,  the  line
          currently being entered.
     reverse-search-history (C-r)
          Search backward starting at the current line and moving
          `up'  through  the  history  as  necessary.  This is an
          incremental search.
     forward-search-history (C-s)
          Search forward starting at the current line and  moving
          `down'  through  the  history as necessary.  This is an
          incremental search.
     non-incremental-reverse-search-history (M-p)
          Search backward through the  history  starting  at  the
          current  line  using  a  non-incremental  search  for a
          string supplied by the user.
     non-incremental-forward-search-history (M-n)
          Search  forward  through  the  history  using  a   non-
          incremental search for a string supplied by the user.
     history-search-forward
          Search forward through the history for  the  string  of
          characters  between  the  start of the current line and
          the current cursor position (the  _p_o_i_n_t).   This  is  a
          non-incremental search.
     history-search-backward
          Search backward through the history for the  string  of
          characters  between  the  start of the current line and
          the point.  This is a non-incremental search.
     yank-nth-arg (M-C-y)
          Insert the first argument to the previous command (usu-
          ally  the  second  word  on the previous line) at point
          (the current cursor position).   With  an  argument  _n,
          insert  the  _nth  word  from  the previous command (the
          words in the previous command begin with  word  0).   A
          negative  argument inserts the _nth word from the end of
          the previous command.
     yank-last-arg (M-., M-_)
          Insert the last argument to the previous  command  (the
          last  word  of  the  previous  history entry).  With an
          argument, behave exactly like yank-nth-arg.
     shell-expand-line (M-C-e)
          Expand the line the way the shell does  when  it  reads
          it.   This performs alias and history expansion as well
          as all of  the  shell  word  expansions.   See  HISTORY
          EXPANSION below for a description of history expansion.
     history-expand-line (M-^)
          Perform history expansion on  the  current  line.   See
          HISTORY  EXPANSION  below  for a description of history



GNU                 Last change: 1996 Nov 25                   42






User Commands                                             BASH(1)



          expansion.
     insert-last-argument (M-., M-_)
          A synonym for yank-last-arg.
     operate-and-get-next (C-o)
          Accept the current line for  execution  and  fetch  the
          next line relative to the current line from the history
          for editing.  Any argument is ignored.

  Commands for Changing Text
     delete-char (C-d)
          Delete the character under the cursor.  If point is  at
          the  beginning  of the line, there are no characters in
          the line, and the last character  typed  was  not  C-d,
          then return EOF.
     backward-delete-char (Rubout)
          Delete the character behind the cursor.  When  given  a
          numeric  argument,  save  the  deleted text on the kill
          ring.
     quoted-insert (C-q, C-v)
          Add the next character that you type to the line verba-
          tim.   This  is  how to insert characters like C-q, for
          example.
     tab-insert (C-v TAB)
          Insert a tab character.
     self-insert (a, b, A, 1, !, ...)
          Insert the character typed.
     transpose-chars (C-t)
          Drag the character before point forward over the  char-
          acter at point.  Point moves forward as well.  If point
          is at the end of the line, then transpose the two char-
          acters before point.  Negative arguments don't work.
     transpose-words (M-t)
          Drag the word behind the cursor past the word in  front
          of the cursor moving the cursor over that word as well.
     upcase-word (M-u)
          Uppercase the current  (or  following)  word.   With  a
          negative  argument,  do  the  previous word, but do not
          move point.
     downcase-word (M-l)
          Lowercase the current  (or  following)  word.   With  a
          negative  argument,  do  the  previous word, but do not
          move point.
     capitalize-word (M-c)
          Capitalize the current (or  following)  word.   With  a
          negative  argument,  do  the  previous word, but do not
          move point.

  Killing and Yanking
     kill-line (C-k)
          Kill the text from the current cursor position  to  the
          end of the line.
     backward-kill-line (C-x Rubout)



GNU                 Last change: 1996 Nov 25                   43






User Commands                                             BASH(1)



          Kill backward to the beginning of the line.
     unix-line-discard (C-u)
          Kill backward from point to the beginning of the line.
     kill-whole-line
          Kill all characters on  the  current  line,  no  matter
          where the cursor is.
     kill-word (M-d)
          Kill from the cursor to the end of the current word, or
          if  between  words,  to the end of the next word.  Word
          boundaries are the same as those used by forward-word.
     backward-kill-word (M-Rubout)
          Kill the word behind the cursor.  Word  boundaries  are
          the same as those used by backward-word.
     unix-word-rubout (C-w)
          Kill the word behind the cursor, using white space as a
          word  boundary.  The word boundaries are different from
          backward-kill-word.
     delete-horizontal-space (M-\)
          Delete all spaces and tabs around point.
     kill-region
          Kill the text between the point and _m_a_r_k (saved  cursor
          position).  This text is referred to as the _r_e_g_i_o_n.
     copy-region-as-kill
          Copy the text in the region to the kill buffer.
     copy-backward-word
          Copy the word before point to the kill buffer.
     copy-forward-word
          Copy the word following point to the kill buffer.
     yank (C-y)
          Yank the top of the kill ring into the  buffer  at  the
          cursor.
     yank-pop (M-y)
          Rotate the kill ring, and yank the new top.  Only works
          following yank or yank-pop.

  Numeric Arguments
     digit-argument (M-0, M-1, ..., M--)
          Add this digit to the argument already accumulating, or
          start a new argument.  M-- starts a negative argument.
     universal-argument
          Each time this is executed, the argument count is  mul-
          tiplied  by four.  The argument count is initially one,
          so executing this function the  first  time  makes  the
          argument count four.

  Completing
     complete (TAB)
          Attempt to perform completion on the text before point.
          Bash  attempts  completion treating the text as a vari-
          able (if the text begins with $), username (if the text
          begins  with  ~), hostname (if the text begins with @),
          or command (including aliases and functions)  in  turn.



GNU                 Last change: 1996 Nov 25                   44






User Commands                                             BASH(1)



          If  none of these produces a match, filename completion
          is attempted.
     possible-completions (M-?)
          List the possible completions of the text before point.
     insert-completions (M-*)
          Insert all completions of the text  before  point  that
          would have been generated by possible-completions.
     complete-filename (M-/)
          Attempt filename completion on the text before point.
     possible-filename-completions (C-x /)
          List the possible completions of the text before point,
          treating it as a filename.
     complete-username (M-~)
          Attempt completion on the text before  point,  treating
          it as a username.
     possible-username-completions (C-x ~)
          List the possible completions of the text before point,
          treating it as a username.
     complete-variable (M-$)
          Attempt completion on the text before  point,  treating
          it as a shell variable.
     possible-variable-completions (C-x $)
          List the possible completions of the text before point,
          treating it as a shell variable.
     complete-hostname (M-@)
          Attempt completion on the text before  point,  treating
          it as a hostname.
     possible-hostname-completions (C-x @)
          List the possible completions of the text before point,
          treating it as a hostname.
     complete-command (M-!)
          Attempt completion on the text before  point,  treating
          it  as  a command name.  Command completion attempts to
          match the text against aliases, reserved  words,  shell
          functions,  builtins, and finally executable filenames,
          in that order.
     possible-command-completions (C-x !)
          List the possible completions of the text before point,
          treating it as a command name.
     dynamic-complete-history (M-TAB)
          Attempt completion on the text before point,  comparing
          the text against lines from the history list for possi-
          ble completion matches.
     complete-into-braces (M-{)
          Perform filename completion and return the list of pos-
          sible completions enclosed within braces so the list is
          available to the shell (see Brace Expansion above).

  Keyboard Macros
     start-kbd-macro (C-x ()
          Begin saving the characters typed into the current key-
          board macro.



GNU                 Last change: 1996 Nov 25                   45






User Commands                                             BASH(1)



     end-kbd-macro (C-x ))
          Stop saving the characters typed into the current  key-
          board macro and store the definition.
     call-last-kbd-macro (C-x e)
          Re-execute the last keyboard macro defined,  by  making
          the  characters  in the macro appear as if typed at the
          keyboard.

  Miscellaneous
     re-read-init-file (C-x C-r)
          Read in the contents of the _i_n_p_u_t_r_c  file,  and  incor-
          porate  any  bindings  or  variable  assignments  found
          there.
     abort (C-g)
          Abort  the  current  editing  command  and   ring   the
          terminal's bell (subject to the setting of bell-style).
     do-uppercase-version (M-a, M-b, M-_x, ...)
          If the metafied character _x is lowercase, run the  com-
          mand that is bound to the corresponding uppercase char-
          acter.
     prefix-meta (ESC)
          Metafy the next character typed.  ESC f  is  equivalent
          to Meta-f.
     undo (C-_, C-x C-u)
          Incremental undo, separately remembered for each line.
     revert-line (M-r)
          Undo all changes made to this line.  This is like  typ-
          ing the undo command enough times to return the line to
          its initial state.
     tilde-expand (M-~)
          Perform tilde expansion on the current word.
     set-mark (C-@, M-<space>)
          Set the mark to the current point.  If a numeric  argu-
          ment is supplied, the mark is set to that position.
     exchange-point-and-mark (C-x C-x)
          Swap the point with the mark.  The current cursor posi-
          tion  is  set to the saved position, and the old cursor
          position is saved as the mark.
     character-search (C-])
          A character is read and point  is  moved  to  the  next
          occurrence   of   that  character.   A  negative  count
          searches for previous occurrences.
     character-search-backward (M-C-])
          A character is read and point is moved to the  previous
          occurrence   of   that  character.   A  negative  count
          searches for subsequent occurrences.
     insert-comment (M-#)
          The value of the  readline  comment-begin  variable  is
          inserted  at the beginning of the current line, and the
          line is accepted as if a newline had been typed.   This
          makes the current line a shell comment.
     glob-expand-word (C-x *)



GNU                 Last change: 1996 Nov 25                   46






User Commands                                             BASH(1)



          The word before point is treated as a pattern for path-
          name  expansion, and the list of matching file names is
          inserted, replacing the word.
     glob-list-expansions (C-x g)
          The list of expansions that would have  been  generated
          by  glob-expand-word  is  displayed,  and  the  line is
          redrawn.
     dump-functions
          Print all of the functions and their  key  bindings  to
          the  readline  output stream.  If a numeric argument is
          supplied, the output is formatted in such a way that it
          can be made part of an _i_n_p_u_t_r_c file.
     dump-variables
          Print all of the settable readline variables and  their
          values  to  the  readline  output stream.  If a numeric
          argument is supplied, the output is formatted in such a
          way that it can be made part of an _i_n_p_u_t_r_c file.
     dump-macros
          Print all of the readline key sequences bound to macros
          and  the  strings they ouput.  If a numeric argument is
          supplied, the output is formatted in such a way that it
          can be made part of an _i_n_p_u_t_r_c file.
     display-shell-version (C-x C-v)
          Display version information about the current  instance
          of bash.

HISTORY
     When the -o history option to the set  builtin  is  enabled,
     the  shell  provides access to the _c_o_m_m_a_n_d _h_i_s_t_o_r_y, the list
     of commands previously typed.  The text of the last HISTSIZE
     commands  (default  500)  is  saved  in a history list.  The
     shell stores each command  in  the  history  list  prior  to
     parameter  and  variable expansion (see EXPANSION above) but
     after history expansion is performed, subject to the  values
     of  the  shell  variables  HISTIGNORE  and  HISTCONTROL.  On
     startup, the history is initialized from the file  named  by
     the  variable  HISTFILE (default ~/._b_a_s_h__h_i_s_t_o_r_y).  HISTFILE
     is truncated, if necessary, to contain no  more  than  HIST-
     FILESIZE  lines.   When an interactive shell exits, the last
     HISTSIZE lines are copied from the history list to HISTFILE.
     If  the histappend shell option is enabled (see the descrip-
     tion of shopt under SHELL BUILTIN COMMANDS below), the lines
     are appended to the history file, otherwise the history file
     is overwritten.  If HISTFILE is unset,  or  if  the  history
     file  is unwritable, the history is not saved.  After saving
     the history, the history file is  truncated  to  contain  no
     more  than  HISTFILESIZE lines.  If HISTFILESIZE is not set,
     no truncation is performed.

     The builtin command fc (see SHELL  BUILTIN  COMMANDS  below)
     may  be used to list or edit and re-execute a portion of the
     history list.  The history builtin can be used to display or



GNU                 Last change: 1996 Nov 25                   47






User Commands                                             BASH(1)



     modify  the  history  list  and manipulate the history file.
     When using the command-line  editing,  search  commands  are
     available  in  each  editing mode that provide access to the
     history list.

     The shell allows control over which commands  are  saved  on
     the  history list.  The HISTCONTROL and HISTIGNORE variables
     may be set to cause the shell to save only a subset  of  the
     commands  entered.   The  cmdhist  shell option, if enabled,
     causes the shell to attempt to save each line  of  a  multi-
     line  command  in  the same history entry, adding semicolons
     where necessary  to  preserve  syntactic  correctness.   The
     lithist  shell  option  causes the shell to save the command
     with embedded  newlines  instead  of  semicolons.   See  the
     description  of  the shopt builtin below under SHELL BUILTIN
     COMMANDS for information  on  setting  and  unsetting  shell
     options.

HISTORY EXPANSION
     The shell supports a history expansion feature that is simi-
     lar to the history expansion in csh.  This section describes
     what syntax features are available.  This feature is enabled
     by default for interactive shells, and can be disabled using
     the +H option to the set builtin command (see SHELL  BUILTIN
     COMMANDS below).  Non-interactive shells do not perform his-
     tory expansion by default.

     History expansions introduce words  from  the  history  list
     into  the  input  stream, making it easy to repeat commands,
     insert the arguments to a previous command into the  current
     input line, or fix errors in previous commands quickly.

     History expansion is performed immediately after a  complete
     line  is  read,  before  the shell breaks it into words.  It
     takes place in two parts.  The first is to  determine  which
     line  from  the previous history to use during substitution.
     The second is to select portions of that line for  inclusion
     into  the  current one.  The line selected from the previous
     history is the _e_v_e_n_t, and the portions of that line that are
     acted  upon  are  _w_o_r_d_s.  Various _m_o_d_i_f_i_e_r_s are available to
     manipulate the selected words.   The  line  is  broken  into
     words  in  the  same  fashion as when reading input, so that
     several _m_e_t_a_c_h_a_r_a_c_t_e_r-separated words surrounded  by  quotes
     are  considered  as one word.  History expansions are intro-
     duced by the appearance of the history expansion  character,
     which is ! by default.  Only backslash (\) and single quotes
     can quote the history expansion character.

     Several shell options settable with the shopt builtin may be
     used  to  tailor  the behavior of history expansion.  If the
     histverify shell option is enabled (see the  description  of
     the  shopt  builtin),  and  readline  is being used, history



GNU                 Last change: 1996 Nov 25                   48






User Commands                                             BASH(1)



     substitutions  are  not  immediately  passed  to  the  shell
     parser.   Instead,  the  expanded  line is reloaded into the
     readline editing buffer for further modification.  If  read-
     line  is  being  used,  and  the  histreedit shell option is
     enabled, a failed history substitution will be reloaded into
     the  readline  editing buffer for correction.  The -p option
     to the history builtin command may be used  to  see  what  a
     history expansion will do before using it.  The -s option to
     the history builtin may be used to add commands to  the  end
     of the history list without actually executing them, so that
     they are available for subsequent recall.

     The shell allows control of the various characters  used  by
     the  history  expansion  mechanism  (see  the description of
     histchars above under Shell Variables).

  Event Designators
     An event designator is a reference to a command  line  entry
     in the history list.

     !    Start a history substitution, except when followed by a
          blank, newline, = or (.
     !_n   Refer to command line _n.
     !-_n  Refer to the current command line minus _n.
     !!   Refer to the previous command.  This is a  synonym  for
          `!-1'.
     !_s_t_r_i_n_g
          Refer to the most recent command starting with _s_t_r_i_n_g.
     !?_s_t_r_i_n_g[?]
          Refer to the most  recent  command  containing  _s_t_r_i_n_g.
          The  trailing  ?  may  be omitted if _s_t_r_i_n_g is followed
          immediately by a newline.
     ^_s_t_r_i_n_g_1^_s_t_r_i_n_g_2^
          Quick substitution.  Repeat the last command, replacing
          _s_t_r_i_n_g_1      with      _s_t_r_i_n_g_2.       Equivalent     to
          ``!!:s/_s_t_r_i_n_g_1/_s_t_r_i_n_g_2/'' (see Modifiers below).
     !#   The entire command line typed so far.

  Word Designators
     Word designators are used to select desired words  from  the
     event.   A : separates the event specification from the word
     designator.  It can be omitted if the word designator begins
     with a ^, $, *, -, or %.  Words are numbered from the begin-
     ning of the line, with the first word  being  denoted  by  0
     (zero).   Words are inserted into the current line separated
     by single spaces.

     0 (zero)
          The zeroth word.  For the shell, this  is  the  command
          word.
     _n    The _nth word.
     ^    The first argument.  That is, word 1.



GNU                 Last change: 1996 Nov 25                   49






User Commands                                             BASH(1)



     $    The last argument.
     %    The word matched by the most recent `?_s_t_r_i_n_g?' search.
     _x-_y  A range of words; `-_y' abbreviates `0-_y'.
     *    All of the words but the zeroth.  This is a synonym for
          `_1-$'.   It  is  not an error to use * if there is just
          one word in the event; the empty string is returned  in
          that case.
     x*   Abbreviates _x-$.
     x-   Abbreviates _x-$ like x*, but omits the last word.

     If a word designator is supplied without an event specifica-
     tion, the previous command is used as the event.

  Modifiers
     After the optional  word  designator,  there  may  appear  a
     sequence  of  one  or  more of the following modifiers, each
     preceded by a `:'.

     h    Remove a trailing file name component, leaving only the
          head.
     t    Remove all leading file name  components,  leaving  the
          tail.
     r    Remove a trailing suffix of the form ._x_x_x, leaving  the
          basename.
     e    Remove all but the trailing suffix.
     p    Print the new command but do not execute it.
     q    Quote the substituted words, escaping further substitu-
          tions.
     x    Quote the substituted words as with q, but  break  into
          words at blanks and newlines.
     s/_o_l_d/_n_e_w/
          Substitute _n_e_w for the first occurrence of _o_l_d  in  the
          event  line.   Any delimiter can be used in place of /.
          The final delimiter is optional if it is the last char-
          acter  of  the event line.  The delimiter may be quoted
          in _o_l_d and _n_e_w with a single backslash.  If  &  appears
          in _n_e_w, it is replaced by _o_l_d.  A single backslash will
          quote the &.  If _o_l_d is null, it is set to the last _o_l_d
          substituted,  or,  if no previous history substitutions
          took place, the last _s_t_r_i_n_g in a !?_s_t_r_i_n_g[?] search.
     &    Repeat the previous substitution.
     g    Cause changes to be applied over the entire event line.
          This   is   used   in   conjunction  with  `:s'  (e.g.,
          `:gs/_o_l_d/_n_e_w/') or `:&'.  If used with `:s', any delim-
          iter can be used in place of /, and the final delimiter
          is optional if it is the last character  of  the  event
          line.

ARITHMETIC EVALUATION
     The shell allows arithmetic  expressions  to  be  evaluated,
     under certain circumstances (see the let builtin command and
     Arithmetic Expansion).  Evaluation is done in long  integers



GNU                 Last change: 1996 Nov 25                   50






User Commands                                             BASH(1)



     with  no check for overflow, though division by 0 is trapped
     and flagged as an error.  The following list of operators is
     grouped into levels of equal-precedence operators.  The lev-
     els are listed in order of decreasing precedence.

     - +  unary minus and plus
     ! ~  logical and bitwise negation
     * / %
          multiplication, division, remainder
     + -  addition, subtraction
     << >>
          left and right bitwise shifts
     <= >= < >
          comparison
     == !=
          equality and inequality
     &    bitwise AND
     ^    bitwise exclusive OR
     |    bitwise OR
     &&   logical AND
     ||   logical OR
     _e_x_p_r?_e_x_p_r:_e_x_p_r
          conditional evaluation
     = *= /= %= += -=
          assignment

     Shell variables are allowed as operands; parameter expansion
     is  performed  before the expression is evaluated. The value
     of a parameter is  coerced  to  a  long  integer  within  an
     expression.   A  shell  variable  need  not have its integer
     attribute turned on to be used in an expression.

     Constants with a leading 0 are interpreted as octal numbers.
     A  leading 0x or 0X denotes hexadecimal.  Otherwise, numbers
     take the form [_b_a_s_e#]n,  where  _b_a_s_e  is  a  decimal  number
     between  2 and 64 representing the arithmetic base, and _n is
     a number in that base.  If _b_a_s_e is omitted, then base 10  is
     used.   The  digits  greater  than  9 are represented by the
     lowercase letters, the uppercase letters, _, and @, in  that
     order.   If  _b_a_s_e is less than or equal to 36, lowercase and
     uppercase letters may be used  interchangably  to  represent
     numbers between 10 and 35.

     Operators  are  evaluated  in  order  of  precedence.   Sub-
     expressions in parentheses are evaluated first and may over-
     ride the precedence rules above.

SHELL BUILTIN COMMANDS
     Unless otherwise noted, each builtin command  documented  in
     this  section  as accepting options preceded by - accepts --
     to signify the end of the options.
     : [_a_r_g_u_m_e_n_t_s]



GNU                 Last change: 1996 Nov 25                   51






User Commands                                             BASH(1)



          No effect; the command does  nothing  beyond  expanding
          _a_r_g_u_m_e_n_t_s and performing any specified redirections.  A
          zero exit code is returned.

      .  _f_i_l_e_n_a_m_e [_a_r_g_u_m_e_n_t_s]
     source _f_i_l_e_n_a_m_e [_a_r_g_u_m_e_n_t_s]
          Read and execute commands from _f_i_l_e_n_a_m_e in the  current
          shell  environment  and  return  the exit status of the
          last command executed from _f_i_l_e_n_a_m_e.  If _f_i_l_e_n_a_m_e  does
          not  contain  a  slash,  file names in PATH are used to
          find  the  directory  containing  _f_i_l_e_n_a_m_e.   The  file
          searched  for  in  PATH  need  not  be executable.  The
          current directory is searched if no file  is  found  in
          PATH.   If  the  sourcepath option to the shopt builtin
          command is turned off, the PATH is  not  searched.   If
          any  _a_r_g_u_m_e_n_t_s are supplied, they become the positional
          parameters when _f_i_l_e_n_a_m_e is  executed.   Otherwise  the
          positional parameters are unchanged.  The return status
          is the status of the last  command  exited  within  the
          script  (0  if  no commands are executed), and false if
          _f_i_l_e_n_a_m_e is not found.

     alias [-p] [_n_a_m_e[=_v_a_l_u_e] ...]
          Alias with no arguments or with the  -p  option  prints
          the  list  of  aliases  in the form alias _n_a_m_e=_v_a_l_u_e on
          standard output.  When arguments are supplied, an alias
          is  defined  for  each  _n_a_m_e  whose  _v_a_l_u_e is given.  A
          trailing space in  _v_a_l_u_e causes the  next  word  to  be
          checked  for  alias  substitution  when  the  alias  is
          expanded.  For each _n_a_m_e in the argument list for which
          no  _v_a_l_u_e  is supplied, the name and value of the alias
          is printed.  Alias returns true unless a _n_a_m_e is  given
          for which no alias has been defined.

     bg [_j_o_b_s_p_e_c]
          Place _j_o_b_s_p_e_c in the background,  as  if  it  had  been
          started with &.  If _j_o_b_s_p_e_c is not present, the shell's
          notion of the _c_u_r_r_e_n_t _j_o_b is used.  bg _j_o_b_s_p_e_c  returns
          0  unless run when job control is disabled or, when run
          with job control enabled, if _j_o_b_s_p_e_c was not  found  or
          started without job control.

     bind [-m _k_e_y_m_a_p] [-lpsvPSV] [-q _n_a_m_e] [-r _k_e_y_s_e_q]
     bind [-m _k_e_y_m_a_p] -f _f_i_l_e_n_a_m_e
     bind [-m _k_e_y_m_a_p] _k_e_y_s_e_q:_f_u_n_c_t_i_o_n-_n_a_m_e
          Display current readline key and function bindings,  or
          bind  a  key  sequence to a readline function or macro.
          The binding syntax accepted is  identical  to  that  of
          ._i_n_p_u_t_r_c, but each binding must be passed as a separate
          argument;   e.g.,   '"\C-x\C-r":    re-read-init-file'.
          Options, if supplied, have the following meanings:
          -m _k_e_y_m_a_p



GNU                 Last change: 1996 Nov 25                   52






User Commands                                             BASH(1)



               Use _k_e_y_m_a_p as the keymap to  be  affected  by  the
               subsequent  bindings.  Acceptable _k_e_y_m_a_p names are
               _e_m_a_c_s, _e_m_a_c_s-_s_t_a_n_d_a_r_d, _e_m_a_c_s-_m_e_t_a, _e_m_a_c_s-_c_t_l_x, _v_i,
               _v_i-_c_o_m_m_a_n_d,  and  _v_i-_i_n_s_e_r_t.   _v_i is equivalent to
               _v_i-_c_o_m_m_a_n_d; _e_m_a_c_s is equivalent to _e_m_a_c_s-_s_t_a_n_d_a_r_d.
          -l   List the names of all readline functions.
          -p   Display readline function names  and  bindings  in
               such a way that they can be re-read.
          -P   List current readline function names and bindings.
          -v   Display readline variable names and values in such
               a way that they can be re-read.
          -V   List current readline variable names and values.
          -s   Display readline key sequences bound to macros and
               the  strings  they  output in such a way that they
               can be re-read.
          -S   Display readline key sequences bound to macros and
               the strings they output.
          -f _f_i_l_e_n_a_m_e
               Read key bindings from _f_i_l_e_n_a_m_e.
          -q _f_u_n_c_t_i_o_n
               Query about which keys invoke the named _f_u_n_c_t_i_o_n.
          -r _k_e_y_s_e_q
               Remove any current binding for _k_e_y_s_e_q.

          The return value is 0 unless an unrecognized option  is
          given or an error occurred.

     break [_n]
          Exit from within a for, while, until, or  select  loop.
          If  _n is specified, break _n levels.  _n must be _> 1.  If
          _n is greater than the number of  enclosing  loops,  all
          enclosing  loops  are  exited.   The  return value is 0
          unless the shell is not executing a loop when break  is
          executed.

     builtin _s_h_e_l_l-_b_u_i_l_t_i_n [_a_r_g_u_m_e_n_t_s]
          Execute the specified shell builtin, passing  it  _a_r_g_u_-
          _m_e_n_t_s, and return its exit status.  This is useful when
          you wish to define a function whose name is the same as
          a  shell  builtin,  but  need  the functionality of the
          builtin within the function itself.  The cd builtin  is
          commonly  redefined  this  way.   The  return status is
          false if _s_h_e_l_l-_b_u_i_l_t_i_n is not a shell builtin command.

     cd [-LP] [_d_i_r]
          Change the current directory to _d_i_r.  The variable HOME
          is  the  default  _d_i_r.  The variable CDPATH defines the
          search path for the directory containing _d_i_r.  Alterna-
          tive directory names in CDPATH are separated by a colon
          (:).  A null directory name in CDPATH is  the  same  as
          the current directory, i.e., ``.''.  If _d_i_r begins with
          a slash (/), then CDPATH is not  used.  The  -P  option



GNU                 Last change: 1996 Nov 25                   53






User Commands                                             BASH(1)



          says to use the physical directory structure instead of
          following symbolic links (see also the -P option to the
          set  builtin  command);  the  -L option forces symbolic
          links to be followed.  An argument of -  is  equivalent
          to  $OLDPWD.  The return value is true if the directory
          was successfully changed; false otherwise.

     command [-pVv] _c_o_m_m_a_n_d [_a_r_g ...]
          Run _c_o_m_m_a_n_d with  _a_r_g_s  suppressing  the  normal  shell
          function  lookup.  Only  builtin  commands  or commands
          found in the PATH are executed.  If the  -p  option  is
          given,  the  search  for  _c_o_m_m_a_n_d  is performed using a
          default value for PATH that is guaranteed to  find  all
          of  the  standard  utilities.   If  either the -V or -v
          option  is  supplied,  a  description  of  _c_o_m_m_a_n_d   is
          printed.  The -v option causes a single word indicating
          the command or file name used to invoke _c_o_m_m_a_n_d  to  be
          printed; the -V option produces a more verbose descrip-
          tion.  If the -V or -v option  is  supplied,  the  exit
          status  is  0  if  _c_o_m_m_a_n_d was found, and 1 if not.  If
          neither option is supplied and  an  error  occurred  or
          _c_o_m_m_a_n_d  cannot be found, the exit status is 127.  Oth-
          erwise, the exit status of the command builtin  is  the
          exit status of _c_o_m_m_a_n_d.

     continue [_n]
          Resume the next iteration of the enclosing for,  while,
          until,  or  select  loop.  If _n is specified, resume at
          the _nth enclosing loop.  _n  must  be  _>  1.   If  _n  is
          greater  than  the  number of enclosing loops, the last
          enclosing loop (the  ``top-level''  loop)  is  resumed.
          The return value is 0 unless the shell is not executing
          a loop when continue is executed.

     declare [-afFirx] [-p] [_n_a_m_e[=_v_a_l_u_e]]
     typeset [-afFirx] [-p] [_n_a_m_e[=_v_a_l_u_e]]
          Declare variables and/or give them attributes.   If  no
          _n_a_m_es  are  given then display the values of variables.
          The -p option will display the attributes and values of
          each  _n_a_m_e.   When  -p  is used, additional options are
          ignored.  The -F option inhibits the display  of  func-
          tion definitions; only the function name and attributes
          are printed.  The -F option implies -f.  The  following
          options  can  be  used  to restrict output to variables
          with the  specified  attribute  or  to  give  variables
          attributes:
          -a   Each _n_a_m_e is an array variable (see Arrays above).
          -f   Use function names only.
          -i   The variable is treated as an integer;  arithmetic
               evaluation  (see  ARITHMETIC  EVALUATION ) is per-
               formed when the variable is assigned a value.
          -r   Make _n_a_m_es readonly.  These names cannot  then  be



GNU                 Last change: 1996 Nov 25                   54






User Commands                                             BASH(1)



               assigned  values  by  subsequent assignment state-
               ments.
          -x   Mark _n_a_m_es for export to subsequent  commands  via
               the environment.

          Using `+'  instead  of  `-'  turns  off  the  attribute
          instead,  with the exception that +a may not be used to
          destroy an array variable.  When used  in  a  function,
          makes  each _n_a_m_e local, as with the local command.  The
          return value is 0 unless an illegal option  is  encoun-
          tered,  an  attempt  is made to define a function using
          "-f foo=bar", an attempt is made to assign a value to a
          readonly variable, an attempt is made to assign a value
          to an array variable without using the compound assign-
          ment syntax (see Arrays above), one of the _n_a_m_e_s is not
          a legal shell variable name, an attempt is made to turn
          off readonly status for a readonly variable, an attempt
          is made to turn off array status for an array variable,
          or  an  attempt is made to display a non-existent func-
          tion with -f.

     dirs [-clpv] [+_n] [-_n]
          Without options, displays the list of currently  remem-
          bered  directories.  The default display is on a single
          line with directory names separated by spaces.   Direc-
          tories  are  added  to the list with the pushd command;
          the popd command removes entries from the list.
          +_n   Displays the _nth entry counting from the  left  of
               the  list  shown  by  dirs  when  invoked  without
               options, starting with zero.
          -_n   Displays the _nth entry counting from the right  of
               the  list  shown  by  dirs  when  invoked  without
               options, starting with zero.
          -c   Clears the directory stack by deleting all of  the
               entries.
          -l   Produces a longer  listing;  the  default  listing
               format uses a tilde to denote the home directory.
          -p   Print the directory stack with one entry per line.
          -v   Print the directory stack with one entry per line,
               prefixing each entry with its index in the stack.

          The return value is 0 unless an illegal option is  sup-
          plied  or  _n  indexes  beyond  the end of the directory
          stack.

     disown [-h] [_j_o_b_s_p_e_c ...]
          Without options, each _j_o_b_s_p_e_c is removed from the table
          of  active jobs.  If the -h option is given, the job is
          not removed from the  table,  but  is  marked  so  that
          SIGHUP  is  not sent to the job if the shell receives a
          SIGHUP.  If no _j_o_b_s_p_e_c is present, the _c_u_r_r_e_n_t  _j_o_b  is
          used.   The return value is 0 unless a _j_o_b_s_p_e_c does not



GNU                 Last change: 1996 Nov 25                   55






User Commands                                             BASH(1)



          specify a valid job.

     echo [-neE] [_a_r_g ...]
          Output the _a_r_gs, separated by  spaces,  followed  by  a
          newline.   The  return  status  is  always 0.  If -n is
          specified, the trailing newline is suppressed.  If  the
          -e  option  is  given,  interpretation of the following
          backslash-escaped characters is enabled.  The -E option
          disables the interpretation of these escape characters,
          even on systems where they are interpreted by  default.
          echo  does not interpret -- to mean the end of options.
          echo interprets the following escape sequences:
          \a   alert (bell)
          \b   backspace
          \c   suppress trailing newline
          \e   an escape character
          \f   form feed
          \n   new line
          \r   carriage return
          \t   horizontal tab
          \v   vertical tab
          \\   backslash
          \nnn the character whose ASCII code is _n_n_n (octal)

     enable [-adnps] [-f _f_i_l_e_n_a_m_e] [_n_a_m_e ...]
          Enable and disable builtin shell commands.  This allows
          the execution of a disk command which has the same name
          as a shell builtin without specifying a full file name.
          If  -n is used, each _n_a_m_e is disabled; otherwise, _n_a_m_e_s
          are enabled.  For example, to use the test binary found
          via  the PATH instead of the shell builtin version, run
          enable -n test.  The -f option means to  load  the  new
          builtin  command  _n_a_m_e  from shared object _f_i_l_e_n_a_m_e, on
          systems that support dynamic loading.   The  -d  option
          will delete a builtin previously loaded with -f.  If no
          _n_a_m_e arguments are given, or if the -p option  is  sup-
          plied,  a  list  of shell builtins is printed.  With no
          other  option  arguments,  the  list  consists  of  all
          enabled  shell  builtins.  If -n is supplied, only dis-
          abled builtins are printed.  If  -a  is  supplied,  the
          list  printed includes all builtins, with an indication
          of whether or not each is enabled.  If -s is  supplied,
          the output is restricted to the POSIX _s_p_e_c_i_a_l builtins.
          The return value is 0 unless a  _n_a_m_e  is  not  a  shell
          builtin  or  there  is  a problem loading a new builtin
          from a shared object.

     eval [_a_r_g ...]
          The _a_r_gs are read and concatenated together into a sin-
          gle command.  This command is then read and executed by
          the shell, and its exit status is returned as the value
          of eval.  If there are no _a_r_g_s, or only null arguments,



GNU                 Last change: 1996 Nov 25                   56






User Commands                                             BASH(1)



          eval returns 0.

     exec [-cl] [-a _n_a_m_e] [_c_o_m_m_a_n_d] [_a_r_g_u_m_e_n_t_s]
          If _c_o_m_m_a_n_d is specified, it replaces the shell.  No new
          process is created.  The _a_r_g_u_m_e_n_t_s become the arguments
          to _c_o_m_m_a_n_d.  If the -l option is  supplied,  the  shell
          places  a  dash  in  the  zeroth arg passed to _c_o_m_m_a_n_d.
          This is what _l_o_g_i_n(1) does.  The -c option causes  _c_o_m_-
          _m_a_n_d  to  be executed with an empty environment.  If -a
          is supplied, the shell passes _n_a_m_e as the zeroth  argu-
          ment  to  the  executed  command.  If _c_o_m_m_a_n_d cannot be
          executed  for  some  reason,  a  non-interactive  shell
          exits,  unless the shell option execfail is enabled, in
          which case it returns failure.   An  interactive  shell
          returns  failure  if  the  file cannot be executed.  If
          _c_o_m_m_a_n_d is not specified, any redirections take  effect
          in the current shell, and the return status is 0.

     exit [_n]
          Cause the shell to exit with a status of _n.   If  _n  is
          omitted,  the  exit  status is that of the last command
          executed.  A trap on EXIT is executed before the  shell
          terminates.

     export [-fn] [_n_a_m_e[=_w_o_r_d]] ...
     export -p
          The supplied _n_a_m_e_s are marked for automatic  export  to
          the  environment of subsequently executed commands.  If
          the -f option is given, the _n_a_m_e_s refer  to  functions.
          If no _n_a_m_e_s are given, or if the -p option is supplied,
          a list of all names that are exported in this shell  is
          printed.   The  -n option causes the export property to
          be removed from the named variables.  export returns an
          exit  status  of  0 unless an illegal option is encoun-
          tered, one of the _n_a_m_e_s is not a legal  shell  variable
          name, or -f is supplied with a _n_a_m_e that is not a func-
          tion.

     fc [-e _e_n_a_m_e] [-nlr] [_f_i_r_s_t] [_l_a_s_t]
     fc -s [_p_a_t=_r_e_p] [_c_m_d]
          Fix Command.  In the first form, a  range  of  commands
          from  _f_i_r_s_t  to _l_a_s_t is selected from the history list.
          _F_i_r_s_t and _l_a_s_t may be specified as a string (to  locate
          the  last  command  beginning with that string) or as a
          number (an index into the history list, where  a  nega-
          tive  number is used as an offset from the current com-
          mand number).  If _l_a_s_t is not specified it  is  set  to
          the  current  command  for  listing  (so that fc -l -10
          prints the last 10 commands) and  to  _f_i_r_s_t  otherwise.
          If  _f_i_r_s_t  is  not  specified it is set to the previous
          command for editing and -16 for listing.




GNU                 Last change: 1996 Nov 25                   57






User Commands                                             BASH(1)



          The -n flag suppresses the command numbers  when  list-
          ing.   The  -r flag reverses the order of the commands.
          If the -l flag is given, the  commands  are  listed  on
          standard  output.  Otherwise, the editor given by _e_n_a_m_e
          is invoked on a file  containing  those  commands.   If
          _e_n_a_m_e is not given, the value of the FCEDIT variable is
          used, and the value of EDITOR if FCEDIT is not set.  If
          neither  variable  is set, _v_i is used.  When editing is
          complete, the edited commands are echoed and executed.

          In the second form, _c_o_m_m_a_n_d is re-executed  after  each
          instance  of _p_a_t is replaced by _r_e_p.  A useful alias to
          use with this is ``r=fc -s'', so that typing  ``r  cc''
          runs  the last command beginning with ``cc'' and typing
          ``r'' re-executes the last command.

          If the first form is used, the return value is 0 unless
          an  illegal  option  is  encountered  or  _f_i_r_s_t or _l_a_s_t
          specify history lines out of range.  If the  -e  option
          is  supplied, the return value is the value of the last
          command executed or failure if an error occurs with the
          temporary  file  of  commands.   If  the second form is
          used, the return status is  that  of  the  command  re-
          executed,  unless  _c_m_d does not specify a valid history
          line, in which case fc returns failure.

     fg [_j_o_b_s_p_e_c]
          Place _j_o_b_s_p_e_c  in  the  foreground,  and  make  it  the
          current  job.   If  _j_o_b_s_p_e_c is not present, the shell's
          notion of the _c_u_r_r_e_n_t _j_o_b is used.  The return value is
          that  of  the  command  placed  into the foreground, or
          failure if run when job control is  disabled  or,  when
          run  with  job  control  enabled,  if  _j_o_b_s_p_e_c does not
          specify a valid job or _j_o_b_s_p_e_c specifies a job that was
          started without job control.

     getopts _o_p_t_s_t_r_i_n_g _n_a_m_e [_a_r_g_s]
          getopts is used by shell procedures to parse positional
          parameters.   _o_p_t_s_t_r_i_n_g  contains the option letters to
          be recognized; if a letter is followed by a colon,  the
          option is expected to have an argument, which should be
          separated from it by white  space.   Each  time  it  is
          invoked,  getopts  places  the next option in the shell
          variable _n_a_m_e, initializing _n_a_m_e if it does not  exist,
          and the index of the next argument to be processed into
          the variable OPTIND.  OPTIND is initialized to  1  each
          time  the  shell or a shell script is invoked.  When an
          option requires an argument, getopts places that  argu-
          ment  into  the  variable  OPTARG.   The shell does not
          reset OPTIND automatically; it must be  manually  reset
          between multiple calls to getopts within the same shell
          invocation if a new set of parameters is to be used.



GNU                 Last change: 1996 Nov 25                   58






User Commands                                             BASH(1)



          getopts can report errors in two ways.   If  the  first
          character of _o_p_t_s_t_r_i_n_g is a colon, _s_i_l_e_n_t error report-
          ing is used.  In normal operation  diagnostic  messages
          are  printed  when  illegal  options  or missing option
          arguments are encountered.  If the variable  OPTERR  is
          set  to  0, no error message will be displayed, even if
          the first character of _o_p_t_s_t_r_i_n_g is not a colon.

          If an illegal option is seen,  getopts  places  ?  into
          _n_a_m_e  and,  if  not silent, prints an error message and
          unsets OPTARG.  If getopts is silent, the option  char-
          acter  found is placed in OPTARG and no diagnostic mes-
          sage is printed.

          If a required argument is not found, and getopts is not
          silent,  a  question mark (?) is placed in _n_a_m_e, OPTARG
          is unset, and a  diagnostic  message  is  printed.   If
          getopts  is  silent, then a colon (:) is placed in _n_a_m_e
          and OPTARG is set to the option character found.

          getopts normally parses the positional parameters,  but
          if  more  arguments  are  given in _a_r_g_s, getopts parses
          those instead.  getopts  returns  true  if  an  option,
          specified  or  unspecified, is found.  It returns false
          if the end  of  options  is  encountered  or  an  error
          occurs.

     hash [-r] [-p _f_i_l_e_n_a_m_e] [_n_a_m_e]
          For each _n_a_m_e, the full file name  of  the  command  is
          determined  by  searching  the directories in $PATH and
          remembered.  If the -p  option  is  supplied,  no  path
          search  is  performed, and _f_i_l_e_n_a_m_e is used as the full
          file name of the command.  The  -r  option  causes  the
          shell  to forget all remembered locations.  If no argu-
          ments are given, information about remembered  commands
          is printed.  The return status is true unless a _n_a_m_e is
          not found or an illegal option is supplied.

     help [_p_a_t_t_e_r_n]
          Display helpful information about builtin commands.  If
          _p_a_t_t_e_r_n  is  specified, help gives detailed help on all
          commands matching _p_a_t_t_e_r_n; otherwise help for  all  the
          builtins  and shell control structures is printed.  The
          return status is 0 unless no command matches _p_a_t_t_e_r_n.

     history [-c] [_n]
     history -anrw [_f_i_l_e_n_a_m_e]
     history -p _a_r_g [_a_r_g ...]
     history -s _a_r_g [_a_r_g ...]
          With no options, display the command history list  with
          line  numbers.   Lines  listed with a * have been modi-
          fied.  An argument of _n lists only the  last  _n  lines.



GNU                 Last change: 1996 Nov 25                   59






User Commands                                             BASH(1)



          If  _f_i_l_e_n_a_m_e is supplied, it is used as the name of the
          history file; if not, the value of  HISTFILE  is  used.
          Options, if supplied, have the following meanings:
          -a   Append the ``new'' history  lines  (history  lines
               entered  since  the  beginning of the current bash
               session) to the history file.
          -n   Read the history lines not already read  from  the
               history file into the current history list.  These
               are lines appended to the history file  since  the
               beginning of the current bash session.
          -r   Read the contents of the history file and use them
               as the current history.
          -w   Write the current history  to  the  history  file,
               overwriting the history file's contents.
          -c   Clear  the  history  list  by  deleting  all   the
               entries.
          -p   Perform history substitution on the following _a_r_g_s
               and  display  the  result  on the standard output.
               Does not store the results in  the  history  list.
               Each  _a_r_g must be quoted to disable normal history
               expansion.
          -s   Store the _a_r_g_s in the history  list  as  a  single
               entry.   The  last  command in the history list is
               removed before the _a_r_g_s are added.

          The return value is  0  unless  an  illegal  option  is
          encountered or an error occurs while reading or writing
          the history file.

     jobs [-lnprs] [ _j_o_b_s_p_e_c ... ]
     jobs -x _c_o_m_m_a_n_d [ _a_r_g_s ... ]
          The first form lists the active jobs.  The options have
          the following meanings:
          -l   List process IDs in addition to the normal  infor-
               mation.
          -p   List only the process  ID  of  the  job's  process
               group leader.
          -n   Display information  only  about  jobs  that  have
               changed status since the user was last notified of
               their status.
          -r   Restrict output to running jobs.
          -s   Restrict output to stopped jobs.

          If _j_o_b_s_p_e_c is given, output is restricted  to  informa-
          tion  about that job.  The return status is 0 unless an
          illegal option is encountered or an illegal _j_o_b_s_p_e_c  is
          supplied.

          If the -x option is supplied, jobs replaces any _j_o_b_s_p_e_c
          found in _c_o_m_m_a_n_d or _a_r_g_s with the corresponding process
          group ID, and executes _c_o_m_m_a_n_d passing it _a_r_g_s, return-
          ing its exit status.



GNU                 Last change: 1996 Nov 25                   60






User Commands                                             BASH(1)



     kill [-s _s_i_g_s_p_e_c | -n _s_i_g_n_u_m | -_s_i_g_s_p_e_c] [_p_i_d | _j_o_b_s_p_e_c] ...
     kill -l [_s_i_g_n_u_m | _s_i_g_s_p_e_c]
          Send the signal named  by  _s_i_g_s_p_e_c  or  _s_i_g_n_u_m  to  the
          processes named by _p_i_d or _j_o_b_s_p_e_c.  _s_i_g_s_p_e_c is either a
          signal name such as SIGKILL or a signal number;  _s_i_g_n_u_m
          is  a  signal number.  If _s_i_g_s_p_e_c is a signal name, the
          name may be given with or without the SIG  prefix.   If
          _s_i_g_s_p_e_c  is  not  present, then SIGTERM is assumed.  An
          argument of -l lists the signal names.   If  any  argu-
          ments  are  supplied when -l is given, the names of the
          specified signals are listed, and the return status  is
          0.   The  arguments to -l may be either signal names or
          signal  numbers;  if  signal  names  are   given,   the
          corresponding signal number is displayed.  kill returns
          true if at least one signal was successfully  sent,  or
          false  if  an  error  occurs  or  an  illegal option is
          encountered.

     let _a_r_g [_a_r_g ...]
          Each _a_r_g is an arithmetic expression  to  be  evaluated
          (see ARITHMETIC EVALUATION).  If the last _a_r_g evaluates
          to 0, let returns 1; 0 is returned otherwise.

     local [_n_a_m_e[=_v_a_l_u_e] ...]
          For each argument, create a local variable named  _n_a_m_e,
          and assign it _v_a_l_u_e.  When local is used within a func-
          tion, it causes the variable _n_a_m_e  to  have  a  visible
          scope  restricted  to  that  function and its children.
          With no operands, local writes a list  of  local  vari-
          ables  to  the  standard output.  It is an error to use
          local when not within a function.  The return status is
          0  unless local is used outside a function, or an ille-
          gal _n_a_m_e is supplied.

     logout
          Exit a login shell.

     popd [-n] [+_n] [-_n]
          Removes entries from  the  directory  stack.   With  no
          arguments,  removes  the  top directory from the stack,
          and performs a cd to the new top directory.  Arguments,
          if supplied, have the following meanings:
          +_n   Removes the _nth entry counting from  the  left  of
               the  list  shown by dirs, starting with zero.  For
               example: ``popd +0'' removes the first  directory,
               ``popd +1'' the second.
          -_n   Removes the _nth entry counting from the  right  of
               the  list  shown by dirs, starting with zero.  For
               example: ``popd -0'' removes the  last  directory,
               ``popd -1'' the next to last.
          -n   Suppresses the normal  change  of  directory  when
               removing  directories from the stack, so that only



GNU                 Last change: 1996 Nov 25                   61






User Commands                                             BASH(1)



               the stack is manipulated.

          If the popd command is successful, a dirs is  performed
          as  well,  and  the  return  status is 0.  popd returns
          false if an illegal option is encountered,  the  direc-
          tory  stack  is  empty,  a non-existent directory stack
          entry is specified, or the directory change fails.

     pushd [-n] [_d_i_r]
     pushd [-n] [+_n] [-_n]
          Adds a directory to the top of the directory stack,  or
          rotates  the stack, making the new top of the stack the
          current  working   directory.    With   no   arguments,
          exchanges the top two directories and returns 0, unless
          the directory stack is empty.  Arguments, if  supplied,
          have the following meanings:
          +_n   Rotates  the  stack  so  that  the  _nth  directory
               (counting from the left of the list shown by dirs)
               is at the top.
          -_n   Rotates  the  stack  so  that  the  _nth  directory
               (counting from the right) is at the top.
          -n   Suppresses the normal  change  of  directory  when
               adding  directories to the stack, so that only the
               stack is manipulated.
          dir  Adds _d_i_r to the directory stack at the top, making
               it the new current working directory.

          If the pushd command is successful, a dirs is performed
          as  well.   If  the first form is used, pushd returns 0
          unless the cd to _d_i_r  fails.   With  the  second  form,
          pushd  returns 0 unless the directory stack is empty, a
          non-existent directory stack element is  specified,  or
          the  directory  change  to  the  specified  new current
          directory fails.

     pwd [-LP]
          Print the absolute file name  of  the  current  working
          directory.   The file name printed contains no symbolic
          links if the -P option is supplied or the  -o  physical
          option  to  the set builtin command is enabled.  If the
          -L option is used, symbolic links  are  followed.   The
          return status is 0 unless an error occurs while reading
          the name of the current directory.

     read [-er] [-a _a_n_a_m_e] [-p _p_r_o_m_p_t] [_n_a_m_e ...]
          One line is read from the standard input, and the first
          word  is assigned to the first _n_a_m_e, the second word to
          the  second  _n_a_m_e,  and  so  on,  with  leftover  words
          assigned  to the last _n_a_m_e.  Only the characters in IFS
          are recognized as word delimiters.   Options,  if  sup-
          plied, have the following meanings:
          -r   A backslash-newline pair is not ignored,  and  the



GNU                 Last change: 1996 Nov 25                   62






User Commands                                             BASH(1)



               backslash is considered to be part of the line.
          -p   Display _p_r_o_m_p_t, without a trailing newline, before
               attempting  to  read  any  input.   The  prompt is
               displayed only if input is coming from a terminal.
          -a   The words are assigned to  sequential  indices  of
               the array variable _a_n_a_m_e, starting at 0.  _a_n_a_m_e is
               unset before any new values are assigned.
          -e   If the standard input is coming from  a  terminal,
               readline  (see  READLINE  above) is used to obtain
               the line.

          If no _n_a_m_e_s are supplied, the line read is assigned  to
          the  variable  REPLY.   The return code is zero, unless
          end-of-file is encountered.

     readonly [-apf] [_n_a_m_e ...]
          The given _n_a_m_e_s are  marked  readonly;  the  values  of
          these  _n_a_m_e_s  may  not be changed by subsequent assign-
          ment.  If the -f  option  is  supplied,  the  functions
          corresponding  to  the  _n_a_m_e_s  are  so  marked.  The -a
          option restricts the variables to arrays.  If  no  _n_a_m_e
          arguments are given, or if the -p option is supplied, a
          list of all readonly  names  is  printed.   The  return
          status  is  0  unless an illegal option is encountered,
          one of the _n_a_m_e_s is not a legal shell variable name, or
          -f is supplied with a _n_a_m_e that is not a function.

     return [_n]
          Causes a function to exit with the return value  speci-
          fied  by _n.  If _n is omitted, the return status is that
          of the last command executed in the function body.   If
          used  outside  a  function,  but  during execution of a
          script by the . (source) command, it causes  the  shell
          to  stop  executing  that script and return either _n or
          the exit status of the last command executed within the
          script  as the exit status of the script.  If used out-
          side a function and not during execution of a script by
          ., the return status is false.

     set [--abefhkmnptuvxBCHP] [-o _o_p_t_i_o_n] [_a_r_g ...]
          Without options, the name and value of each shell vari-
          able  are  displayed in a format that can be re-used as
          input.  When options are specified, they set  or  unset
          shell  attributes.   Any  arguments remaining after the
          options are processed are treated  as  values  for  the
          positional  parameters  and  are assigned, in order, to
          $1, $2, ... $_n.  Options, if specified, have  the  fol-
          lowing meanings:
          -a      Automatically mark variables which are modified
                  or  created  for  export  to the environment of
                  subsequent commands.
          -b      Report the status of terminated background jobs



GNU                 Last change: 1996 Nov 25                   63






User Commands                                             BASH(1)



                  immediately,  rather  than before the next pri-
                  mary prompt.  This is effective only  when  job
                  control is enabled.
          -e      Exit immediately if a _s_i_m_p_l_e _c_o_m_m_a_n_d (see SHELL
                  GRAMMAR  above)  exits  with a non-zero status.
                  The shell does not exit  if  the  command  that
                  fails  is  part of an _u_n_t_i_l or _w_h_i_l_e loop, part
                  of an _i_f statement, part of a && or || list, or
                  if the command's return value is being inverted
                  via !.
          -f      Disable pathname expansion.
          -h      Remember the location of commands as  they  are
                  looked   up  for  execution.   This  is  on  by
                  default.
          -k      All arguments in the form of assignment  state-
                  ments  are placed in the environment for a com-
                  mand, not just those that precede  the  command
                  name.
          -m      Monitor mode.  Job control  is  enabled.   This
                  flag is on by default for interactive shells on
                  systems  that  support  it  (see  JOB   CONTROL
                  above).  Background processes run in a separate
                  process group and a line containing their  exit
                  status is printed upon their completion.
          -n      Read commands but do not  execute  them.   This
                  may  be used to check a shell script for syntax
                  errors.  This is ignored by interactive shells.
          -o _o_p_t_i_o_n-_n_a_m_e
                  The _o_p_t_i_o_n-_n_a_m_e can be one of the following:
                  allexport
                          Same as -a.
                  braceexpand
                          Same as -B.
                  emacs   Use an emacs-style command line editing
                          interface.   This is enabled by default
                          when the shell is  interactive,  unless
                          the shell is started with the --noedit-
                          ing option.
                  errexit Same as -e.
                  hashall Same as -h.
                  histexpand
                          Same as -H.
                  history Enable command  history,  as  described
                          above under HISTORY.  This option is on
                          by default in interactive shells.
                  ignoreeof
                          The effect is as if the  shell  command
                          IGNOREEOF=10  had  been  executed  (see
                          Shell Variables above).
                  keyword Same as -k.
                  monitor Same as -m.
                  noclobber



GNU                 Last change: 1996 Nov 25                   64






User Commands                                             BASH(1)



                          Same as -C.
                  noexec  Same as -n.
                  noglob  Same as -f.
                  notify  Same as -b.
                  nounset Same as -u.
                  onecmd  Same as -t.
                  physical
                          Same as -P.
                  posix   Change the behavior of bash  where  the
                          default   operation  differs  from  the
                          POSIX  1003.2  standard  to  match  the
                          standard.
                  privileged
                          Same as -p.
                  verbose Same as -v.
                  vi      Use a  vi-style  command  line  editing
                          interface.
                  xtrace  Same as -x.
                  If -o is  supplied  with  no  _o_p_t_i_o_n-_n_a_m_e,  the
                  values  of the current options are printed.  If
                  +o is supplied with no _o_p_t_i_o_n-_n_a_m_e, a series of
                  set  commands  to  recreate  the current option
                  settings is displayed on the standard output.
          -p      Turn on _p_r_i_v_i_l_e_g_e_d mode.   In  this  mode,  the
                  $ENV file is not processed, and shell functions
                  are not inherited from the  environment.   This
                  is  enabled  automatically  on  startup  if the
                  effective user (group) id is not equal  to  the
                  real  user (group) id.  Turning this option off
                  causes the effective user and group ids  to  be
                  set to the real user and group ids.
          -t      Exit after reading and executing one command.
          -u      Treat unset variables as an error when perform-
                  ing   parameter  expansion.   If  expansion  is
                  attempted  on  an  unset  variable,  the  shell
                  prints  an  error message, and, if not interac-
                  tive, exits with a non-zero status.
          -v      Print shell input lines as they are read.
          -x      After expanding each  _s_i_m_p_l_e  _c_o_m_m_a_n_d,  display
                  the expanded value of PS4, followed by the com-
                  mand and its expanded arguments.
          -B      The shell performs brace expansion  (see  Brace
                  Expansion above).  This is on by default.
          -C      If set, bash does  not  overwrite  an  existing
                  file  with the >, >&, and <> redirection opera-
                  tors.  This may  be  overridden  when  creating
                  output  files by using the redirection operator
                  >| instead of >.
          -H      Enable ! style history substitution.  This flag
                  is on by default when the shell is interactive.
          -P      If set, the  shell  does  not  follow  symbolic
                  links  when  executing commands such as cd that



GNU                 Last change: 1996 Nov 25                   65






User Commands                                             BASH(1)



                  change the current working directory.  It  uses
                  the  physical  directory structure instead.  By
                  default, bash  follows  the  logical  chain  of
                  directories   when  performing  commands  which
                  change the current directory.
          --      If no arguments  follow  this  flag,  then  the
                  positional  parameters  are  unset.  Otherwise,
                  the positional parameters are set to the  _a_r_gs,
                  even if some of them begin with a -.
          -       Signal the end of options, cause all  remaining
                  _a_r_gs  to  be assigned to the positional parame-
                  ters.  The -x and -v options  are  turned  off.
                  If there are no _a_r_gs, the positional parameters
                  remain unchanged.

          The flags are off by default  unless  otherwise  noted.
          Using  +  rather than - causes these flags to be turned
          off.  The flags can also be specified as options to  an
          invocation  of the shell.  The current set of flags may
          be found in $-.   The  return  status  is  always  true
          unless an illegal option is encountered.

     shift [_n]
          The positional parameters from _n+1 ... are  renamed  to
          $1  ....  Parameters represented by the numbers $# down
          to $#-_n+1 are unset.  _n must be a  non-negative  number
          less than or equal to $#.  If _n is 0, no parameters are
          changed.  If _n is not given, it is assumed to be 1.  If
          _n is greater than $#, the positional parameters are not
          changed.  The return status is greater than zero  if  _n
          is greater than $# or less than zero; otherwise 0.

     shopt [-pqsu] [-o] [_o_p_t_n_a_m_e ...]
          Toggle the values  of  variables  controlling  optional
          shell  behavior.   With  no  options,  or  with  the -p
          option, a list of all settable  options  is  displayed,
          with  an  indication  of  whether  or  not each is set.
          Other options have the following meanings:
          -s   Enable (set) each _o_p_t_n_a_m_e.
          -u   Disable (unset) each _o_p_t_n_a_m_e.
          -q   Suppresses normal output (quiet mode); the  return
               status  indicates  whether  the  _o_p_t_n_a_m_e is set or
               unset.  If multiple _o_p_t_n_a_m_e  arguments  are  given
               with -q, the return status is zero if all _o_p_t_n_a_m_e_s
               are enabled; non-zero otherwise.
          -o   Restricts  the  values  of  _o_p_t_n_a_m_e  to  be  those
               defined for the -o option to the set builtin.

          If either -s or -u is used with no  _o_p_t_n_a_m_e  arguments,
          the  display  is limited to those options which are set
          or unset, respectively.  Unless  otherwise  noted,  the
          shopt options are disabled (unset) by default.



GNU                 Last change: 1996 Nov 25                   66






User Commands                                             BASH(1)



          The return status when listing options is zero  if  all
          _o_p_t_n_a_m_e_s are enabled, non-zero otherwise.  When setting
          or unsetting options, the return status is zero  unless
          an _o_p_t_n_a_m_e is not a legal shell option.

          The list of shopt options is:

          cdable_vars
                  If set, an argument to the cd  builtin  command
                  that  is  not  a directory is assumed to be the
                  name of a variable whose value is the directory
                  to change to.
          cdspell If set, minor  errors  in  the  spelling  of  a
                  directory  component  in  a  cd command will be
                  corrected.  The errors checked  for  are  tran-
                  sposed characters, a missing character, and one
                  character too many.  If a correction is  found,
                  the  corrected  file  name  is printed, and the
                  command proceeds.  This option  is  enabled  by
                  default,   but  is  only  used  by  interactive
                  shells.
          checkhash
                  If set, bash checks that a command found in the
                  hash  table exists before trying to execute it.
                  If a hashed command no longer exists, a  normal
                  path search is performed.
          checkwinsize
                  If set, bash checks the window size after  each
                  command  and,  if necessary, updates the values
                  of LINES and COLUMNS.
          cmdhist If set, bash attempts to save all  lines  of  a
                  multiple-line   command  in  the  same  history
                  entry.  This allows easy re-editing  of  multi-
                  line commands.
          dotglob If set, bash includes filenames beginning  with
                  a `.' in the results of pathname expansion.
          execfail
                  If set, a non-interactive shell will  not  exit
                  if  it  cannot execute the file specified as an
                  argument  to  the  exec  builtin  command.   An
                  interactive shell does not exit if exec fails.
          expand_aliases
                  If set, aliases are expanded as described above
                  under  ALIASES.   This  option  is  enabled  by
                  default for interactive shells.
          histappend
                  If set, the history list  is  appended  to  the
                  file  named  by the value of the HISTFILE vari-
                  able  when  the  shell   exits,   rather   than
                  overwriting the file.
          histreedit
                  If set, and readline is being used, a  user  is



GNU                 Last change: 1996 Nov 25                   67






User Commands                                             BASH(1)



                  given  the opportunity to re-edit a failed his-
                  tory substitution.
          histverify
                  If set, and readline is being used, the results
                  of  history  substitution  are  not immediately
                  passed  to  the  shell  parser.   Instead,  the
                  resulting  line  is  loaded  into  the readline
                  editing buffer, allowing further modification.
          hostcomplete
                  If set, and readline is being used,  bash  will
                  attempt  to  perform hostname completion when a
                  word beginning with @ is being  completed  (see
                  Completing  under  READLINE  above).   This  is
                  enabled by default.
          interactive_comments
                  If set, allow a word beginning with # to  cause
                  that  word and all remaining characters on that
                  line to be ignored in an interactive shell (see
                  COMMENTS  above).   This  option  is enabled by
                  default.
          lithist If set, and  the  cmdhist  option  is  enabled,
                  multi-line  commands  are  saved to the history
                  with embedded newlines rather than using  semi-
                  colon separators where possible.
          mailwarn
                  If set, and a file that bash  is  checking  for
                  mail  has  been accessed since the last time it
                  was checked, the message ``The mail in _m_a_i_l_f_i_l_e
                  has been read'' is displayed.
          nullglob
                  If set, bash allows  patterns  which  match  no
                  files  (see Pathname Expansion above) to expand
                  to a null string, rather than themselves.
          promptvars
                  If set, prompt  strings  undergo  variable  and
                  parameter  expansion  after  being  expanded as
                  described in PROMPTING above.  This  option  is
                  enabled by default.
          shift_verbose
                  If set, the shift builtin prints an error  mes-
                  sage when the shift count exceeds the number of
                  positional parameters.
          sourcepath
                  If set, the source (.) builtin uses  the  value
                  of  PATH  to  find the directory containing the
                  file supplied as an argument.  This is  enabled
                  by default.
     suspend [-f]
          Suspend the execution of this shell until it receives a
          SIGCONT  signal.  The -f option says not to complain if
          this is a login shell; just suspend anyway.  The return
          status is 0 unless the shell is a login shell and -f is



GNU                 Last change: 1996 Nov 25                   68






User Commands                                             BASH(1)



          not supplied, or if job control is not enabled.
     test _e_x_p_r
     [ _e_x_p_r ]
          Return a status of 0 or 1 depending on  the  evaluation
          of the conditional expression _e_x_p_r.  Expressions may be
          unary or binary.  Unary expressions are often  used  to
          examine  the status of a file.  There are string opera-
          tors and numeric comparison operators  as  well.   Each
          operator  and  operand must be a separate argument.  If
          _f_i_l_e is of the form /dev/fd/_n, then file  descriptor  _n
          is  checked.  Expressions are composed of the following
          primaries:
          -b _f_i_l_e
               True if _f_i_l_e exists and is a block special file.
          -c _f_i_l_e
               True if _f_i_l_e exists and  is  a  character  special
               file.
          -d _f_i_l_e
               True if _f_i_l_e exists and is a directory.
          -e _f_i_l_e
               True if _f_i_l_e exists.
          -f _f_i_l_e
               True if _f_i_l_e exists and is a regular file.
          -g _f_i_l_e
               True if _f_i_l_e exists and is set-group-id.
          -k _f_i_l_e
               True if _f_i_l_e has its ``sticky'' bit set.
          -L _f_i_l_e
               True if _f_i_l_e exists and is a symbolic link.
          -p _f_i_l_e
               True if _f_i_l_e exists and is a named pipe.
          -r _f_i_l_e
               True if _f_i_l_e exists and is readable.
          -s _f_i_l_e
               True if _f_i_l_e exists and has a  size  greater  than
               zero.
          -S _f_i_l_e
               True if _f_i_l_e exists and is a socket.
          -t _f_d
               True if _f_d is opened on a terminal.
          -u _f_i_l_e
               True if _f_i_l_e exists and  its  set-user-id  bit  is
               set.
          -w _f_i_l_e
               True if _f_i_l_e exists and is writable.
          -x _f_i_l_e
               True if _f_i_l_e exists and is executable.
          -O _f_i_l_e
               True if _f_i_l_e exists and is owned by the  effective
               user id.
          -G _f_i_l_e
               True if _f_i_l_e exists and is owned by the  effective



GNU                 Last change: 1996 Nov 25                   69






User Commands                                             BASH(1)



               group id.
          _f_i_l_e_1 -nt _f_i_l_e_2
               True if _f_i_l_e_1 is newer (according to  modification
               date) than _f_i_l_e_2.
          _f_i_l_e_1 -ot _f_i_l_e_2
               True if _f_i_l_e_1 is older than _f_i_l_e_2.
          _f_i_l_e_1 -ef _f_i_l_e_2
               True if _f_i_l_e_1 and _f_i_l_e_2 have the same  device  and
               inode numbers.
          -o _o_p_t_n_a_m_e
               True if shell option _o_p_t_n_a_m_e is enabled.  See  the
               list  of  options  under the description of the -o
               option to the set builtin above.
          -z _s_t_r_i_n_g
               True if the length of _s_t_r_i_n_g is zero.
          -n _s_t_r_i_n_g
          _s_t_r_i_n_g
               True if the length of _s_t_r_i_n_g is non-zero.
          _s_t_r_i_n_g_1 = _s_t_r_i_n_g_2
               True if the strings are equal.  == may be used  in
               place of =.
          _s_t_r_i_n_g_1 != _s_t_r_i_n_g_2
               True if the strings are not equal.
          _s_t_r_i_n_g_1 < _s_t_r_i_n_g_2
               True if _s_t_r_i_n_g_1 sorts before _s_t_r_i_n_g_2 lexicographi-
               cally.
          _s_t_r_i_n_g_1 > _s_t_r_i_n_g_2
               True if _s_t_r_i_n_g_1 sorts after _s_t_r_i_n_g_2  lexicographi-
               cally.
          ! _e_x_p_r
               True if _e_x_p_r is false.
          _e_x_p_r_1 -a _e_x_p_r_2
               True if both _e_x_p_r_1 AND _e_x_p_r_2 are true.
          _e_x_p_r_1 -o _e_x_p_r_2
               True if either _e_x_p_r_1 OR _e_x_p_r_2 is true.
          _a_r_g_1 OP _a_r_g_2
               OP is one of -eq, -ne,  -lt,  -le,  -gt,  or  -ge.
               These  arithmetic  binary operators return true if
               _a_r_g_1 is equal to, not equal to,  less  than,  less
               than or equal to, greater than, or greater than or
               equal to _a_r_g_2, respectively.  _A_r_g_1 and _a_r_g_2 may be
               positive or negative integers.

     times
          Print the accumulated user and  system  times  for  the
          shell and for processes run from the shell.  The return
          status is 0.

     trap [-lp] [_a_r_g] [_s_i_g_s_p_e_c]
          The command _a_r_g is to be read  and  executed  when  the
          shell  receives signal(s) _s_i_g_s_p_e_c.  If _a_r_g is absent or
          -, all specified signals are reset  to  their  original



GNU                 Last change: 1996 Nov 25                   70






User Commands                                             BASH(1)



          values  (the  values  they  had  upon  entrance  to the
          shell).  If _a_r_g is  the  null  string  this  signal  is
          ignored  by  the  shell and by the commands it invokes.
          If _a_r_g is -p then the  trap  commands  associated  with
          each  _s_i_g_s_p_e_c  are displayed.  If no arguments are sup-
          plied or if only -p is given, trap prints the  list  of
          commands  associated  with each signal number.  _s_i_g_s_p_e_c
          is either a signal name defined  in  <_s_i_g_n_a_l._h>,  or  a
          signal  number.  If _s_i_g_s_p_e_c is EXIT (0) the command _a_r_g
          is executed on exit from  the  shell.   If  _s_i_g_s_p_e_c  is
          DEBUG,  the  command _a_r_g is executed after every _s_i_m_p_l_e
          _c_o_m_m_a_n_d (see  SHELL  GRAMMAR  above).   The  -l  option
          causes  the  shell  to print a list of signal names and
          their  corresponding  numbers.   Signals  ignored  upon
          entry to the shell cannot be trapped or reset.  Trapped
          signals are reset to their original values in  a  child
          process when it is created.  The return status is false
          if any _s_i_g_s_p_e_c is invalid; otherwise trap returns true.

     type [-all] [-type | -path] _n_a_m_e [_n_a_m_e ...]
          With no options, indicate how each _n_a_m_e would be inter-
          preted if used as a command name.  If the -type flag is
          used, type prints a string which is one of _a_l_i_a_s,  _k_e_y_-
          _w_o_r_d,  _f_u_n_c_t_i_o_n,  _b_u_i_l_t_i_n, or _f_i_l_e if _n_a_m_e is an alias,
          shell reserved word, function, builtin, or  disk  file,
          respectively.   If  the _n_a_m_e is not found, then nothing
          is printed, and an exit status of  false  is  returned.
          If the -path flag is used, type either returns the name
          of the disk file that would be executed  if  _n_a_m_e  were
          specified  as a command name, or nothing if -type would
          not return _f_i_l_e.  If a command is hashed, -path  prints
          the hashed value, not necessarily the file that appears
          first in PATH.  If the -all flag is used,  type  prints
          all  of  the  places  that  contain an executable named
          _n_a_m_e.  This includes aliases and functions, if and only
          if  the  -path  flag  is  not  also used.  The table of
          hashed commands is not consulted when using -all.  type
          accepts  -a,  -t,  and  -p in place of -all, -type, and
          -path, respectively.  type returns true if any  of  the
          arguments are found, false if none are found.

     ulimit [-SHacdflmnpstuv [_l_i_m_i_t]]
          Provides control over the resources  available  to  the
          shell  and  to processes started by it, on systems that
          allow such control.  The value of _l_i_m_i_t can be a number
          in  the  unit  specified for the resource, or the value
          unlimited.  The -H and -S options specify that the hard
          or  soft  limit  is set for the given resource.  A hard
          limit cannot be increased once it is set; a soft  limit
          may be increased up to the value of the hard limit.  If
          neither -H nor -S is specified, both the soft and  hard
          limits are set.  If _l_i_m_i_t is omitted, the current value



GNU                 Last change: 1996 Nov 25                   71






User Commands                                             BASH(1)



          of the soft limit of the resource  is  printed,  unless
          the -H option is given.  When more than one resource is
          specified, the limit name and unit are  printed  before
          the value.  Other options are interpreted as follows:
          -a   All current limits are reported
          -c   The maximum size of core files created
          -d   The maximum size of a process's data segment
          -f   The maximum size of files created by the shell
          -l   The maximum size that may be locked into memory
          -m   The maximum resident set size
          -n   The maximum number of open file descriptors  (most
               systems do not allow this value to be set)
          -p   The pipe size in 512-byte blocks (this may not  be
               set)
          -s   The maximum stack size
          -t   The maximum amount of cpu time in seconds
          -u   The maximum number of  processes  available  to  a
               single user
          -v   The maximum amount of virtual memory available  to
               the shell

          If _l_i_m_i_t is given, it is the new value of the specified
          resource (the -a option is display only).  If no option
          is given, then -f is assumed.  Values are in  1024-byte
          increments,  except  for  -t,  which is in seconds, -p,
          which is in units of 512-byte blocks, and  -n  and  -u,
          which  are  unscaled  values.   The  return status is 0
          unless an illegal option is encountered, a  non-numeric
          argument  other than unlimited is supplied as _l_i_m_i_t, or
          an error occurs while setting a new limit.

     umask [-S] [_m_o_d_e]
          The user file-creation mask is set to  _m_o_d_e.   If  _m_o_d_e
          begins  with  a  digit,  it  is interpreted as an octal
          number; otherwise it is interpreted as a symbolic  mode
          mask  similar to that accepted by _c_h_m_o_d(1).  If _m_o_d_e is
          omitted, or if the -S option is supplied,  the  current
          value of the mask is printed.  The -S option causes the
          mask to be printed in symbolic form; the default output
          is an octal number.  The return status is 0 if the mode
          was successfully changed or if  no  _m_o_d_e  argument  was
          supplied, and false otherwise.

     unalias [-a] [_n_a_m_e ...]
          Remove _n_a_m_es from the list of defined aliases.   If  -a
          is  supplied,  all  alias definitions are removed.  The
          return value is true unless a supplied _n_a_m_e  is  not  a
          defined alias.

     unset [-fv] [_n_a_m_e ...]
          For each _n_a_m_e, remove  the  corresponding  variable  or
          function.  If no options are supplied, or the -v option



GNU                 Last change: 1996 Nov 25                   72






User Commands                                             BASH(1)



          is given, each _n_a_m_e refers to a shell variable.   Read-
          only  variables  may  not be unset.  If -f is specifed,
          each _n_a_m_e refers to a shell function, and the  function
          definition is removed.  Each unset variable or function
          is removed from the environment  passed  to  subsequent
          commands.   If any of RANDOM, SECONDS, LINENO, HISTCMD,
          or DIRSTACK are unset, they lose their special  proper-
          ties,  even  if  they are subsequently reset.  The exit
          status is true unless a  _n_a_m_e  does  not  exist  or  is
          readonly.

     wait [_n]
          Wait for the specified process and return its  termina-
          tion status.  _n may be a process ID or a job specifica-
          tion; if a job spec is given,  all  processes  in  that
          job's  pipeline are waited for.  If _n is not given, all
          currently active child processes are  waited  for,  and
          the  return  status  is  zero.   If  _n specifies a non-
          existent process or job,  the  return  status  is  127.
          Otherwise,  the return status is the exit status of the
          last process or job waited for.

RESTRICTED SHELL
     If bash is started with the name rbash, or the -r option  is
     supplied  at  invocation,  the  shell becomes restricted.  A
     restricted shell is used to set up an environment more  con-
     trolled  than the standard shell.  It behaves identically to
     bash with the exception that the following are disallowed:

     +o    changing directories with cd

     +o    setting or unsetting the values of SHELL or PATH

     +o    specifying command names containing /

     +o    specifying a file name containing a / as an argument to
          the . builtin command

     +o    importing function definitions from the shell  environ-
          ment at startup

     +o    redirecting output using the >, >|, <>, >&, &>, and  >>
          redirection operators

     +o    using the exec builtin command  to  replace  the  shell
          with another command

     +o    adding or deleting builtin commands with the -f and  -d
          options to the enable builtin command

     +o    specifying the -p option to the command builtin command




GNU                 Last change: 1996 Nov 25                   73






User Commands                                             BASH(1)



     +o    turning off restricted mode with set +r.

     These restrictions are enforced after any startup files  are
     read.

     When a command that is found to be a shell  script  is  exe-
     cuted  (see  COMMAND  EXECUTION  above), rbash turns off any
     restrictions in the shell spawned to execute the script.

SEE ALSO
     _B_a_s_h _F_e_a_t_u_r_e_s, Brian Fox and Chet Ramey
     _T_h_e _G_n_u _R_e_a_d_l_i_n_e _L_i_b_r_a_r_y, Brian Fox and Chet Ramey
     _T_h_e _G_n_u _H_i_s_t_o_r_y _L_i_b_r_a_r_y, Brian Fox and Chet Ramey
_U_t_i_l_i_t_i_e_s, IEEE
     _P_o_r_t_a_b_l_e _O_p_e_r_a_t_i_n_g _S_y_s_t_e_m _I_n_t_e_r_f_a_c_e (_P_O_S_I_X)  _P_a_r_t  _2:  _S_h_e_l_l  _a_n_d
     _s_h(1), _k_s_h(1), _c_s_h(1)
     _e_m_a_c_s(1), _v_i(1)
     _r_e_a_d_l_i_n_e(3)

FILES
     /_b_i_n/_b_a_s_h
          The bash executable
     /_e_t_c/_p_r_o_f_i_l_e
          The systemwide initialization file, executed for  login
          shells
     ~/._b_a_s_h__p_r_o_f_i_l_e
          The personal initialization file,  executed  for  login
          shells
     ~/._b_a_s_h_r_c
          The individual per-interactive-shell startup file
     ~/._i_n_p_u_t_r_c
          Individual _r_e_a_d_l_i_n_e initialization file

AUTHORS
     Brian Fox, Free Software Foundation
     bfox@gnu.ai.MIT.Edu

     Chet Ramey, Case Western Reserve University
     chet@ins.CWRU.Edu

BUG REPORTS
     If you find a bug in bash, you should report it.  But first,
     you  should  make  sure that it really is a bug, and that it
     appears in the latest version of bash that you have.

     Once you have determined that a bug actually exists, use the
     _b_a_s_h_b_u_g  command to submit a bug report.  If you have a fix,
     you are welcome to mail that as well!  Suggestions and `phi-
     losophical'    bug   reports   may   be   mailed   to   _b_u_g-
     _b_a_s_h@_p_r_e_p._a_i._M_I_T._E_d_u  or  posted  to  the  Usenet  newsgroup
     gnu.bash.bug.




GNU                 Last change: 1996 Nov 25                   74






User Commands                                             BASH(1)



     ALL bug reports should include:

     The version number of bash
     The hardware and operating system
     The compiler used to compile
     A description of the bug behaviour
     A short script or `recipe' which exercises the bug

     _b_a_s_h_b_u_g inserts the first three items automatically into the
     template it provides for filing a bug report.

     Comments and bug reports concerning this manual page  should
     be directed to _c_h_e_t@_i_n_s._C_W_R_U._E_d_u.

BUGS
     It's too big and too slow.

     There are some subtle differences between  bash  and  tradi-
     tional  versions of sh, mostly because of the POSIX specifi-
     cation.

     Aliases are confusing in some uses.

     Shell   builtin   commands    and    functions    are    not
     stoppable/restartable.

     Compound commands and command sequences of the form `a ; b ;
     c'  are  not  handled  gracefully when process suspension is
     attempted.  When a process is stopped, the shell immediately
     executes  the  next command in the sequence.  It suffices to
     place the sequence of commands between parentheses to  force
     it into a subshell, which may be stopped as a unit.

     Commands inside  of  $(...)  command  substitution  are  not
     parsed  until  substitution  is  attempted.  This will delay
     error  reporting  until  some  time  after  the  command  is
     entered.

     Array variables may not (yet) be exported.
















GNU                 Last change: 1996 Nov 25                   75



