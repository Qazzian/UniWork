\setcounter{slide}{95}
%
% slide 114
%
\begin{slide}{}
{\bf Code Generation}

Code generation is the final phase in compilation.
From an intermediate represention of the source program,
the code generator produces a target program.

The code generator's main tasks are
\begin{itemize}
\item memory management,
\item register allocation and
\item instruction selection.
\end{itemize}
\end{slide}
%
% slide 115
%
\begin{slide}{}
{\bf Code Generation}

The code that is generated should be                              
\begin{itemize}
\item compact,
\item fast and
\item effective in its use of machine resources.
\end{itemize}
\end{slide}
%
% slide 116
%
\begin{slide}{}
{\bf Memory Management}

The code generated by the code generator implements a
memory management strategy.  This means determing
\begin{itemize}
\item when variables are to be bound to storage, and
\item where storage is to be allocated in memory.
\end{itemize}

Variables appear as names in 3-address code. Each name
in a 3-address statement refers to a symbol table entry.
The entry includes information about the type of the named
data item.  The code generator uses this type information
to produce code that allocates a suitable amount of space
for the data item.
\end{slide}
%
% slide 117
%
\begin{slide}{}
{\bf Register Allocation}

Register allocation entails
\begin{itemize}
\item selecting the variables that will reside in registers, and
\item choosing the specific register in which each variable
      will reside.
\end{itemize}

Register allocation must be well done if the target code is to
be compact and fast.
\end{slide}
%
% slide 118                     
%
\begin{slide}{}
{\bf Instruction Selection}

Instruction selection means choosing suitable target
machine instructions to implement the intermediate program.

For example, suppose the target machine includes an instruction\\                     
\begin{verbatim}
    INC
\end{verbatim}
to add one to a register.  Then\\                    
\begin{verbatim}
    INC R0
\end{verbatim}
is a better translation of a := a + 1 than\\
\begin{verbatim}
    MOV a, R0
    ADD #1, R0
    MOV R0, a
\end{verbatim}
\end{slide}
%
% slide 119
%
\begin{slide}{}
{\bf Flow of Control Information}                           

The code generator uses information about the
flow of control of the intermediate program to
produce efficient target code.

This flow of control information is represented
as a flow graph.

Nodes in the flow graph represent {\em basic blocks}
of instructions, in which control passes sequentially
from instruction to instruction.

Edges in the flow graph represent transfers of control.
\end{slide}
%
% slide 120
%
\begin{slide}{}
{\bf Basic Blocks}

In a 3-address program, a basic block is a sequence of
3-address statements in which control begins at the
first instruction, and passes through to the last instruction
without halting or branching.

For example,
\begin{verbatim}
    t1 := a * a
    t2 := a * b
    a  := t1 + t2
\end{verbatim}
is a basic block.

A basic block computes a set of expressions.  These expressions
are the values of the names that are {\em live} on exit from
the basic block.
\end{slide}
%
% slide 121
%
\begin{slide}{}
{\bf Flow Graphs for 3-address Programs}

A flow graph of a 3-address program has basic
blocks of 3-address statements as its nodes.

The node that contains the first statement of
the program is called the initial node.

Suppose B1 and B2 are nodes.  There is a directed
edge from B1 to B2 if
\begin{itemize}
\item there is a jump from the last statement of B1
      the first statement of B2, or
\item B2 follows B1 in the program, and B1 does not
      end in an unconditional jump.
\end{itemize}
\end{slide}
%
% slide 122
%
\begin{slide}{}
{\bf Flow Graphs for 3-address Programs}

Example

\vspace{3ex}
\epsfbox{flow-graph.eps}

\end{slide}
%
% slide 123
%
\begin{slide}{}
{\bf Next Use Information}

The code generator collects next use information
to help decide how to use registers and temporary
storage.  The general strategy is to keep a name
in storage only if it will be used again.

Next use information is collected by scanning the
basic blocks backwards, and recording for each name
in a block whether the name has a next use in the
block, and, if not, whether it is live on exit from
the block.
\end{slide}
%
% slide 124
%
\begin{slide}{}
{\bf A Simple Code Generator -- Aho, Sethi and Ullman}

\begin{description}
\item[Input] -- a sequence of 3-address statements
\item[Output] -- target code
\item[Strategy] -- consider each of the 3-address
    statements in turn, ``remembering'' if any of the
    operands are currently in registers, and taking
    advantage of that fact if possible.
\end{description}

Computed results are left in registers as long as possible,
and are stored only when the register is needed for another
computation, or a procedure call, jump or labelled statement
is encountered.
\end{slide}
%
% slide 125
%
\begin{slide}{}
{\bf A Simple Code Generator}

Important Data Structures
\begin{description}
\item[Register Descriptor] -- current contents of each register.
\item[Address Descriptor] -- where current value of a name can be
    found at run time; e.g. in a register, on the stack, in memory.
\end{description}

Important Function
\begin{description}
\item[get reg] -- a procedure that returns
    the address of a 
    location L in which to store the result of a
    3-address assignment.
    Usually L will be a register, but it could
    be a memory location.
\end{description}     

\end{slide}
%
% slide 126
%
\begin{slide}{}
{\small
{\bf Code Generation Algorithm}

For 3-address statements of the form
{\tt x := y op z}

\begin{itemize}                     
\item Call `get reg' to determine the location L
  where the result of y op z will be stored.

\item Look up
   $y^\prime $, the current location of y in the address descriptor;
  if y is both in memory and in a
  register, choose the register. Unless the
  value of y is already in L, generate {\tt MOV y', L}

\item  Determine $z^\prime$, the current location of z in
   and generate {\tt OP z', L}

\item  Update the address descriptor to indicate
  that L is the location of the current
  value of x.  If L is a register, update
  its register descriptor to indicate that
  it holds the value of x, and remove x from
  all other register descriptors.

\item   If the current values of y (or z) has no
  next uses, and is not live on exit from
  the current basic block, and is in a
  register, then alter the register
  descriptor to free the register.
\end{itemize}
}
\end{slide}
%
% slide 127
%
\begin{slide}{}
{\small
{\bf Code Generation Algorithm -- continued}

Code generation is done in a similar way for {\tt x := op y}

For a statement like {\tt x := y}
\begin{itemize}
\item  If y is in a register, modify the
  address and register descriptors to say
  that x is now there.  If y has no next
  use, modify the register descriptors to
  say that y is no longer there.

\item  If y is in memory, and x has no next use
  in the block, generate {\tt MOV y, x}

\item  If y is in memory, and x has a next use
  in the block, use `getreg' to find a
  register in which to load y, and make
  that register the location of x.
\end{itemize}
}
\end{slide}
%
% slide 128
%
\begin{slide}{}
{\bf Example}

Generating code for
\begin{verbatim}
    d:= (a-b) + (a-c) + (a-c)
\end{verbatim}

{\small
\begin{tabular}{|l|l|l|l|}
\hline
3-address & target & register   & address\\
code      & code   & descriptor & descriptor\\
\hline
           &            & all registers & \\
           &            &     empty & \\
\cline{3-4}
t := a - b & MOV a, R0  & R0 contains t & t in R0\\
           & SUB b, R0  &               & \\
\cline{3-4}
u := a - c & MOV a, R1  & R0 contains t & t in R0\\
           & SUB c, R1  & R1 contains u & u in R1\\
\cline{3-4}
v := t + u & ADD R1, R0 & R0 contains v & v in R0\\
           &            & R1 contains u & u in R1\\
\cline{3-4}
d := v + u & ADD R1, R0 & R0 contains d & d in R0\\
           & MOV R0, d  &               & and in \\
           &            &               & memory\\
\hline
\end{tabular}
}
\end{slide}
