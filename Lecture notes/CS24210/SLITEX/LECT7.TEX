\setcounter{slide}{110}
%
% slide 129
%
\begin{slide}{}
{\bf Optimisation}

Optimisation means using algorithms and heuristics with
the aim of improving the code generated by the compiler.

An immense number of these are known.

Some are used in almost all production compilers.

Others are only used in special {\em optimising compilers}.

The term ``optimising compiler'' is not strictly accurate.
Optimisation includes some undecidable problems, and some
whose solution is prohibitively expensive.
\end{slide}
%
% slide 130
%
\begin{slide}{}
{\bf Structure of an Optimising Compiler}

\vspace{3ex}
\epsfbox{opt-compiler.eps}

\end{slide}
%
% slide 131
%
\begin{slide}{}
{\bf Criteria by which Optimisations are Judged (Fischer, LeBlanc)}

Optimisations are judged by their
safety and profitability.

For example suppose the loop
\begin{verbatim}
    while J < I loop
        A(J) := 10/I;
        J := J+2;
    end loop;
\end{verbatim}
is transformed to
\begin{verbatim}
    t1 := 10/I;
    while J < I loop
        A(J) := t1;
        J := J+2;
    end loop;
\end{verbatim}

What if I=0 or J$\ge$I initially?

\end{slide}
%
% slide 117
%
\begin{slide}{}
{\bf Classification of Optimisations}

{\bf 1. Source Language Optimisations are}               
    \begin{itemize}
    \item performed by semantic routines,
    \item language specific and
    \item machine independent
    \end{itemize}
\end{slide}
%
% slide 117
%
\begin{slide}{}
{\bf Source Language Optimisations}

Example: Loop Unscrolling
\begin{verbatim}
    for I in 1..10 loop
        A(I) := 2*I;
    end loop;
\end{verbatim}
is changed to
\begin{verbatim}      
    A(1) := 2;
    A(2) := 4;
    ...
    A(10):= 20;
\end{verbatim}
\end{slide}
%
% slide 117
%
\begin{slide}{}
{\bf Classification of Optimisations}

{\bf 2. Target Code Optimisations}
    \begin{itemize}
    \item exploit target machine architecture and
    \item are source language independent.                     
    \end{itemize}

Example:
\begin{verbatim}
    MPY 2,Y
\end{verbatim}
is changed to
\begin{verbatim}
    SHIFTLEFT y
\end{verbatim}
\end{slide}
%
% slide 117
%
\begin{slide}{}
{\bf Classification of Optimisations}

{\bf 3. Intermediate Representation Optimisations}

\begin{itemize}
\item depend solely on the intermediate representation,
\item can be shared by many compilers for different source
      languages or target machines or both
\item entail processing flow graphs of basic blocks
\end{itemize}
\end{slide}
%
% slide 122
%
\begin{slide}{}
{\bf Flow Graph for a quicksort program (Aho, Sethi and Ullman)}

Consider the following flow graph for a quicksort program.

The graph has been taken from Aho, Sethi and Ullman, page 591,
Figure 10.5; the optimisation examples that follow have all been 
taken from the same source. 

The code assumes that each element of the array a takes 4 bytes. 
\end{slide}
%
% slide 122
%
\begin{slide}{}
{\bf Flow Graph for a quicksort program }

\vspace{3ex}
\epsfbox{quicksort.eps}

\end{slide}

%
% slide 122
%
\begin{slide}{}
{\bf Some Useful Optimisations}
\begin{itemize}
\item elimination of common subexpressions
\item copy propagation
\item dead code elimination
\item loop optimisations
 \begin{itemize}
 \item code motion
 \item induction variable elimination
 \item strength reduction
 \end{itemize}
\end{itemize}
\end{slide}
%
% slide 122
%
\begin{slide}{}
{\bf Local elimination of common subexpressions}

Consider block B5 from the quicksort program 

{\bf Before \hspace{7em} After}\\
\begin{verbatim}
B5: t6 := 4*i       B5: t6 := 4*i
    x  := a[t6]         x  := a[t6]
    t7 := 4*i           t8 := 4*j
    t8 := 4*j           t9 := a[t8]
    t9 := a[t8]         a[t6] := t9
    a[t7] := t9         a[t8] := x
    t10 := 4*j          goto B2
    a[t10] := x
    goto B2
\end{verbatim}
\end{slide}
%
% slide 122
%
\begin{slide}{}
{\bf Quicksort flow graph before global elimination of common subexpressions} 

\vspace{3ex}
\epsfbox{qs_glob1.eps}

\end{slide}
%
% slide 122
%
\begin{slide}{}
{\bf Quicksort flow graph after global elimination of common subexpressions} 

\vspace{3ex}
\epsfbox{qs_glob2.eps}

\end{slide}
%
% slide 122
%
\begin{slide}{}
{\bf Copy propagation}

Following a copy statement {\tt f := g} use {\tt g} in place of {\tt f} wherever possible.

Consider block B5 after global elimination of common subexpressions

{\bf Before \hspace{7em} After}\\
\begin{verbatim}
B5: x := t3           B5: x := t3
    a[t2] := t5           a[t2] := t5
    a[t4] := x            a[t4] := t3
    goto B2               goto B2
\end{verbatim}

So what?
\end{slide}

%
% slide 122
%
\begin{slide}{}
{\bf Dead code elimination}

A variable is live at a point in a program if its value is subsequently used;
otherwise it is dead.

A piece of code is live if the value(s) it computes is (are) used subsequently; otherwise it is dead.

Copy propagation often turns the copy statement into dead code, which
can be eliminated.

Block B5 again

{\bf Before  \hspace{7em} After}\\
\begin{verbatim}
B5: x := t3         B5: a[t2] := t5 
    a[t2] := t5         a[t4] := t3
    a[t4] := t3         goto B2 
    goto B2                 
\end{verbatim}

\end{slide}

%
% slide 139
%
\begin{slide}{}
{\small
{\bf Code Motion}

Move code out of a loop to a point before the loop; 
this avoids recomputing values.

{\bf Before \hspace{7em} After}\\
\begin{verbatim}
Start: m := 10             Start: m := 10
       n := 50                    n := 50
Loop:  a[n] := m*4                t1 := m*4
       b[n] := m+15               t2 := m+15
       n := n-1            Loop:  a[n] := t1
       if n >= 1 goto Loop        b[n] := t2
                                  n := n-1
                                  if n >= 1 goto Loop
\end{verbatim}

Note: this is not part of the quicksort example!
}
\end{slide}
%
% slide 140
%
\begin{slide}{}
{\bf Induction Variable Elimination}

In the loop round B2 in the quicksort flow graph, every time {\tt i} is incremented 
\begin{verbatim}
t2 := 4*i
\end{verbatim}
is recalculated.  This means that the relationship
\begin{verbatim}
t2 = 4*i
\end{verbatim}
is maintained.

{\tt i} and {\tt t2} are called induction variables

It is often possible to eliminate all but one of the induction variables
in a loop.

However, before this can be done in the quicksort example, some further
manipulation is needed.
\end{slide}

%
% slide 141
%
\begin{slide}{}
{\small
{\bf Strength Reduction}

Replace slower operations (like multiplication) by faster ones (like addition) in a loop.

In block B2, provided
\begin{verbatim}
t2 = 4*i
\end{verbatim}
the statements 
\begin{verbatim}
i := i+1
t2 := 4*i
\end{verbatim}
can be replaced by
\begin{verbatim}
i := i+1
t2 := t2+4
\end{verbatim}

It remains to establish 
\begin{verbatim}
t2 = 4*i
\end{verbatim}
at the point of entry to B2.  This is done by modifying B1, where i
is initialised.

A similar transformation can be carried out in B3.
}
\end{slide}

%
% slide 142
%
\begin{slide}{}
{\bf Strength Reduction in blocks B2 and B3}

\vspace{3ex}
\epsfbox{strength_red.eps}
\end{slide}
%
% slide 143
%
\begin{slide}{}
{\small
{\bf Back to induction variable elimination}

Consider {\tt i} and {\tt j} in B2, B3, B4 and B5

After strength reduction in B2 and B3, {\tt i} and {\tt j} are
only used in the test in B4.

Because
\begin{verbatim}
t2 = 4*i
\end{verbatim}
and
\begin{verbatim}
t4 = 4*j
\end{verbatim}
this test can be replaced by
\begin{verbatim}
t2 >= t4
\end{verbatim}

Also, the statements
\begin{verbatim}
i := i+1
\end{verbatim}
in B2
and 
\begin{verbatim}
j := j-1
\end{verbatim}
in B3
are now dead code, and can be eliminated.
}
\end{slide}
%
% slide 144
%
\begin{slide}{}
{\bf The final flow graph}

\vspace{3ex}
\epsfbox{qsort_final.eps}
\end{slide}

%
% slide 145
%
\begin{slide}{}
{\bf Compilation Systems - Summary}

\begin{itemize}
\item Structure of a compiler
\item Lexical analysis (scanning)
\item Syntactic analysis (parsing)
\item Semantic analysis (context sensitive checking)
\item Code Generation
\item Optimisation
\end{itemize}
\end{slide}
